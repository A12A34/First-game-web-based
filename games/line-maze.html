<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Line Maze - Game Hub</title>
    <link rel="stylesheet" href="../css/styles.css">
    <style>
        .fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            font-size: 1.2rem;
            z-index: 1000;
            transition: all 0.3s;
        }
        .fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        .game-container { max-width: 520px; }

        .info-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 10px;
            font-size: 0.9rem;
            color: #ccc;
            flex-wrap: wrap;
            font-family: 'Courier New', monospace;
        }
        .info-row .val { color: #00ff88; font-weight: bold; }
        .info-row .accent { color: #00d9ff; font-weight: bold; }

        .progress-wrap {
            width: 100%;
            max-width: 400px;
            margin: 0 auto 10px;
        }
        .progress-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: #00d9ff80;
            font-family: 'Courier New', monospace;
            margin-bottom: 3px;
        }
        .progress-outer {
            width: 100%;
            height: 6px;
            background: #1a1a2e;
            border: 1px solid #00d9ff40;
            border-radius: 3px;
            overflow: hidden;
        }
        .progress-inner {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            border-radius: 3px;
            transition: width 0.1s linear;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            border: 2px solid #00d9ff40;
            border-radius: 8px;
            background: #050510;
            touch-action: none;
        }

        .touch-controls {
            display: flex;
            justify-content: center;
            gap: 24px;
            margin-top: 12px;
        }
        .touch-btn {
            width: 90px;
            height: 64px;
            border: 2px solid #00d9ff;
            background: rgba(0, 217, 255, 0.08);
            color: #00d9ff;
            font-size: 1.6rem;
            border-radius: 12px;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.12s;
        }
        .touch-btn:active, .touch-btn.active {
            background: rgba(0, 217, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 217, 255, 0.4);
            transform: scale(0.95);
        }

        .start-btn {
            display: block;
            margin: 15px auto;
            padding: 14px 40px;
            background: transparent;
            border: 2px solid #00d9ff;
            color: #00d9ff;
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .start-btn:hover {
            background: rgba(0, 217, 255, 0.15);
            box-shadow: 0 0 25px rgba(0, 217, 255, 0.3);
        }

        .game-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.88);
            z-index: 100;
            align-items: center;
            justify-content: center;
        }
        .game-overlay.show { display: flex; }
        .overlay-box {
            background: rgba(10, 10, 20, 0.96);
            border: 2px solid #00d9ff;
            border-radius: 12px;
            padding: 32px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            font-family: 'Courier New', monospace;
            color: #00d9ff;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        .overlay-box.death { border-color: #ff6b6b; }
        .overlay-box.death h2 { color: #ff6b6b; text-shadow: 0 0 15px rgba(255,107,107,0.5); }
        .overlay-box.success { border-color: #00ff88; }
        .overlay-box.success h2 { color: #00ff88; text-shadow: 0 0 15px rgba(0,255,136,0.5); }
        .overlay-box h2 {
            font-size: 1.5rem;
            margin-bottom: 12px;
        }
        .overlay-stats {
            margin: 18px 0;
            font-size: 0.9rem;
            line-height: 2;
            color: #ccc;
        }
        .overlay-stats span { color: #00ff88; }
        .overlay-btn {
            padding: 12px 28px;
            background: transparent;
            border: 2px solid #00d9ff;
            color: #00d9ff;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            cursor: pointer;
            border-radius: 6px;
            margin: 5px;
            transition: all 0.2s;
        }
        .overlay-btn:hover {
            background: rgba(0, 217, 255, 0.15);
            box-shadow: 0 0 15px rgba(0, 217, 255, 0.3);
        }
        .overlay-btn.green { border-color: #00ff88; color: #00ff88; }
        .overlay-btn.green:hover { background: rgba(0,255,136,0.15); }
        .overlay-btn.red { border-color: #ff6b6b; color: #ff6b6b; }
        .overlay-btn.red:hover { background: rgba(255,107,107,0.15); }

        @media (max-width: 500px) {
            .touch-btn { width: 78px; height: 56px; font-size: 1.4rem; }
        }
    </style>
</head>
<body>
    <button class="fullscreen-btn" id="fullscreenBtn">&#x26F6;</button>
    <div class="container">
        <a href="../index.html" class="back-btn">&larr; Back to Games</a>
        <div class="game-container">
            <h1 class="game-title">&#128256; Line Maze</h1>
            <div class="info-row">
                <div>LEVEL: <span class="accent" id="levelDisp">1</span></div>
                <div>SCORE: <span class="val" id="scoreDisp">0</span></div>
                <div>BEST: <span class="val" id="highDisp">0</span></div>
            </div>
            <div class="progress-wrap">
                <div class="progress-label">
                    <span>START</span>
                    <span id="distLabel">0m</span>
                    <span>FINISH</span>
                </div>
                <div class="progress-outer">
                    <div class="progress-inner" id="progressFill"></div>
                </div>
            </div>
            <canvas id="gameCanvas" width="400" height="600"></canvas>
            <div class="touch-controls">
                <button class="touch-btn" id="btnLeft">&#9664;</button>
                <button class="touch-btn" id="btnRight">&#9654;</button>
            </div>
            <button class="start-btn" id="startBtn">START</button>
            <div class="instructions">
                <h3>How to Play</h3>
                <p>Guide the glowing line through a twisting corridor without hitting the walls.</p>
                <ul style="text-align:left;color:#ccc;font-size:0.9rem;margin-top:8px;line-height:1.8;">
                    <li>The line moves <strong>forward automatically</strong></li>
                    <li>Press <strong>Left/Right arrows</strong> or <strong>A/D</strong> to steer</li>
                    <li>Tap the <strong>arrow buttons</strong> on mobile</li>
                    <li>Touching the <strong>neon walls</strong> means instant death</li>
                    <li>Reach the <strong>finish line</strong> to clear the level</li>
                    <li>Each level is <strong>faster</strong> with <strong>narrower</strong> corridors</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="game-overlay" id="gameOverOverlay">
        <div class="overlay-box death">
            <h2>WALL HIT!</h2>
            <div class="overlay-stats" id="gameOverStats"></div>
            <div>
                <button class="overlay-btn" onclick="startGame()">PLAY AGAIN</button>
                <button class="overlay-btn red" onclick="resetToMenu()">MENU</button>
            </div>
        </div>
    </div>

    <div class="game-overlay" id="levelOverlay">
        <div class="overlay-box success">
            <h2>LEVEL COMPLETE!</h2>
            <div class="overlay-stats" id="levelStats"></div>
            <div>
                <button class="overlay-btn green" onclick="nextLevel()">NEXT LEVEL</button>
            </div>
        </div>
    </div>

    <script>
    /* ===================== Fullscreen ===================== */
    document.getElementById('fullscreenBtn').addEventListener('click', () => {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(() => {});
        else document.exitFullscreen();
    });

    /* ===================== Canvas Setup ===================== */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const W = canvas.width;
    const H = canvas.height;
    const PLAYER_Y = H - 90;

    /* ===================== Game State ===================== */
    let g = {
        playing: false,
        level: 1,
        score: 0,
        highScore: parseInt(localStorage.getItem('lineMazeHighScore') || '0'),
        dist: 0,
        px: W / 2,
        speed: 0,
        steerSpeed: 0,
        cw: 0,
        levelLen: 0,
        waypoints: [],
        trail: [],
        steering: 0,
        particles: [],
        raf: null
    };
    document.getElementById('highDisp').textContent = g.highScore;

    /* ===================== Level Config ===================== */
    function levelCfg(lv) {
        return {
            corridorWidth: Math.max(52, 185 - (lv - 1) * 13),
            speed: 2.2 + (lv - 1) * 0.22,
            steerSpeed: 4.2 + (lv - 1) * 0.35,
            levelLength: 3200 + (lv - 1) * 450,
            segLength: Math.max(45, 95 - (lv - 1) * 4),
            maxShift: Math.min(135, 55 + (lv - 1) * 9)
        };
    }

    /* ===================== Corridor Generation ===================== */
    function generateWaypoints(cfg) {
        const wps = [];
        const n = Math.ceil(cfg.levelLength / cfg.segLength) + 6;
        const minCx = cfg.corridorWidth / 2 + 18;
        const maxCx = W - cfg.corridorWidth / 2 - 18;
        let cx = W / 2;

        /* Safe starting zone */
        for (let i = 0; i < 4; i++) {
            wps.push({ d: i * cfg.segLength, cx: W / 2 });
        }
        cx = W / 2;

        for (let i = 4; i <= n; i++) {
            let shift = (Math.random() - 0.5) * 2 * cfg.maxShift;
            shift += (W / 2 - cx) * 0.12;
            cx = Math.max(minCx, Math.min(maxCx, cx + shift));
            wps.push({ d: i * cfg.segLength, cx: cx });
        }
        return wps;
    }

    function getCenter(dist) {
        if (dist <= 0) return g.waypoints[0].cx;
        const seg = levelCfg(g.level).segLength;
        let i = Math.floor(dist / seg);
        i = Math.max(0, Math.min(g.waypoints.length - 2, i));
        const a = g.waypoints[i];
        const b = g.waypoints[i + 1];
        let t = (dist - a.d) / (b.d - a.d);
        t = Math.max(0, Math.min(1, t));
        t = t * t * (3 - 2 * t);
        return a.cx + (b.cx - a.cx) * t;
    }

    function getWidth(dist) {
        const base = g.cw;
        const pulse = Math.sin(dist * 0.007) * 0.12 + Math.sin(dist * 0.0025) * 0.08;
        return base * (1 + pulse);
    }

    /* ===================== Game Lifecycle ===================== */
    function startGame() {
        const cfg = levelCfg(g.level);
        g.playing = true;
        g.dist = 0;
        g.px = W / 2;
        g.speed = cfg.speed;
        g.steerSpeed = cfg.steerSpeed;
        g.cw = cfg.corridorWidth;
        g.levelLen = cfg.levelLength;
        g.waypoints = generateWaypoints(cfg);
        g.trail = [];
        g.particles = [];
        g.steering = 0;

        if (idleRaf) { cancelAnimationFrame(idleRaf); idleRaf = null; }

        document.getElementById('startBtn').style.display = 'none';
        document.getElementById('gameOverOverlay').classList.remove('show');
        document.getElementById('levelOverlay').classList.remove('show');
        document.getElementById('levelDisp').textContent = g.level;
        document.getElementById('progressFill').style.width = '0%';
        document.getElementById('distLabel').textContent = '0m';

        if (g.raf) cancelAnimationFrame(g.raf);
        gameLoop();
    }

    function update() {
        if (!g.playing) return;

        g.dist += g.speed;

        if (g.steering !== 0) {
            g.px += g.steering * g.steerSpeed;
        }
        g.px = Math.max(5, Math.min(W - 5, g.px));

        g.trail.push({ x: g.px, d: g.dist });
        if (g.trail.length > 220) g.trail.shift();

        /* Ambient particles */
        if (Math.random() < 0.25) {
            const rd = g.dist + Math.random() * H * 0.9;
            const rc = getCenter(rd);
            const rw = getWidth(rd) / 2;
            g.particles.push({
                x: rc + (Math.random() - 0.5) * rw * 1.6,
                d: rd,
                a: 0.15 + Math.random() * 0.25,
                s: 1 + Math.random() * 1.5,
                life: 1
            });
        }
        g.particles = g.particles.filter(p => {
            p.life -= 0.006;
            return p.life > 0 && p.d > g.dist - 50;
        });
        if (g.particles.length > 70) g.particles.splice(0, g.particles.length - 70);

        /* Collision */
        const cx = getCenter(g.dist);
        const hw = getWidth(g.dist) / 2;
        if (g.px - 4 < cx - hw || g.px + 4 > cx + hw) {
            gameOver();
            return;
        }

        /* Level complete */
        if (g.dist >= g.levelLen) {
            levelComplete();
            return;
        }

        /* UI updates */
        const pct = Math.min(100, (g.dist / g.levelLen) * 100);
        document.getElementById('progressFill').style.width = pct + '%';
        document.getElementById('distLabel').textContent = Math.floor(g.dist) + 'm';
    }

    /* ===================== Rendering ===================== */
    function render() {
        ctx.fillStyle = '#050510';
        ctx.fillRect(0, 0, W, H);

        drawGrid();
        drawCorridorFill();
        drawDistanceMarkers();
        drawFinishLine();
        drawParticles();
        drawWalls();
        drawTrail();
        drawPlayer();
    }

    function drawGrid() {
        ctx.strokeStyle = 'rgba(0,217,255,0.025)';
        ctx.lineWidth = 1;
        const gs = 40;
        const off = g.dist % gs;
        for (let y = off - gs; y < H + gs; y += gs) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(W, y);
            ctx.stroke();
        }
        for (let x = 0; x < W; x += gs) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, H);
            ctx.stroke();
        }
    }

    function worldToScreen(worldDist) {
        return PLAYER_Y - (worldDist - g.dist);
    }

    function buildWallPaths() {
        const left = [], right = [];
        const step = 3;
        for (let sy = -12; sy <= H + 12; sy += step) {
            const wd = g.dist + (PLAYER_Y - sy);
            if (wd < -100 || wd > g.levelLen + 300) continue;
            const cx = getCenter(wd);
            const hw = getWidth(wd) / 2;
            left.push({ x: cx - hw, y: sy });
            right.push({ x: cx + hw, y: sy });
        }
        return { left, right };
    }

    function drawCorridorFill() {
        const { left, right } = buildWallPaths();
        if (left.length < 2) return;

        ctx.fillStyle = 'rgba(0,217,255,0.018)';
        ctx.beginPath();
        ctx.moveTo(left[0].x, left[0].y);
        for (const p of left) ctx.lineTo(p.x, p.y);
        for (let i = right.length - 1; i >= 0; i--) ctx.lineTo(right[i].x, right[i].y);
        ctx.closePath();
        ctx.fill();

        /* Center dashed guide line */
        ctx.strokeStyle = 'rgba(0,217,255,0.06)';
        ctx.lineWidth = 1;
        ctx.setLineDash([6, 10]);
        ctx.beginPath();
        for (let sy = -12; sy <= H + 12; sy += 3) {
            const wd = g.dist + (PLAYER_Y - sy);
            if (wd < 0 || wd > g.levelLen) continue;
            const cx = getCenter(wd);
            if (sy === -12 || sy === 0) ctx.moveTo(cx, sy);
            else ctx.lineTo(cx, sy);
        }
        ctx.stroke();
        ctx.setLineDash([]);
    }

    function drawWalls() {
        const { left, right } = buildWallPaths();
        drawNeonWall(left);
        drawNeonWall(right);
    }

    function drawNeonWall(path) {
        if (path.length < 2) return;

        /* Outer glow */
        ctx.save();
        ctx.shadowColor = '#00d9ff';
        ctx.shadowBlur = 18;
        ctx.strokeStyle = 'rgba(0,217,255,0.5)';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(path[0].x, path[0].y);
        for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
        ctx.stroke();

        /* Core line */
        ctx.shadowBlur = 10;
        ctx.strokeStyle = '#00d9ff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(path[0].x, path[0].y);
        for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
        ctx.stroke();

        /* Hot center */
        ctx.shadowBlur = 0;
        ctx.strokeStyle = 'rgba(255,255,255,0.45)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(path[0].x, path[0].y);
        for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
        ctx.stroke();
        ctx.restore();
    }

    function drawDistanceMarkers() {
        const interval = 500;
        const first = Math.ceil(Math.max(0, g.dist - 100) / interval) * interval;
        for (let md = first; md <= g.dist + H + 50; md += interval) {
            if (md <= 0 || md > g.levelLen) continue;
            const sy = worldToScreen(md);
            if (sy < -15 || sy > H + 15) continue;

            const cx = getCenter(md);
            const hw = getWidth(md) / 2;

            ctx.strokeStyle = 'rgba(0,217,255,0.12)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 5]);
            ctx.beginPath();
            ctx.moveTo(cx - hw + 6, sy);
            ctx.lineTo(cx + hw - 6, sy);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = 'rgba(0,217,255,0.25)';
            ctx.font = '10px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(md + 'm', cx, sy - 6);
        }
    }

    function drawFinishLine() {
        const sy = worldToScreen(g.levelLen);
        if (sy < -30 || sy > H + 30) return;

        const fcx = getCenter(g.levelLen);
        const fhw = getWidth(g.levelLen) / 2;
        const sz = 8;

        for (let fx = Math.floor((fcx - fhw) / sz) * sz; fx < fcx + fhw; fx += sz) {
            for (let row = 0; row < 3; row++) {
                const fy = sy - sz + row * sz;
                const checker = ((Math.floor(fx / sz) + row) % 2 === 0);
                ctx.fillStyle = checker ? 'rgba(0,255,136,0.55)' : 'rgba(0,255,136,0.15)';
                ctx.fillRect(fx, fy, sz, sz);
            }
        }

        ctx.save();
        ctx.shadowColor = '#00ff88';
        ctx.shadowBlur = 16;
        ctx.strokeStyle = '#00ff88';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(fcx - fhw, sy);
        ctx.lineTo(fcx + fhw, sy);
        ctx.stroke();
        ctx.restore();

        ctx.fillStyle = 'rgba(0,255,136,0.5)';
        ctx.font = 'bold 12px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('FINISH', fcx, sy - 18);
    }

    function drawParticles() {
        for (const p of g.particles) {
            const sy = worldToScreen(p.d);
            if (sy < -10 || sy > H + 10) continue;
            ctx.fillStyle = 'rgba(0,217,255,' + (p.a * p.life).toFixed(3) + ')';
            ctx.beginPath();
            ctx.arc(p.x, sy, p.s, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function drawTrail() {
        if (g.trail.length < 2) return;
        ctx.lineCap = 'round';

        const batchSize = 4;
        let started = false;

        for (let i = 1; i < g.trail.length; i++) {
            const p0 = g.trail[i - 1];
            const p1 = g.trail[i];
            const sy0 = worldToScreen(p0.d);
            const sy1 = worldToScreen(p1.d);

            if (sy0 > H + 20 && sy1 > H + 20) continue;
            if (sy0 < -20 && sy1 < -20) continue;

            const t = i / g.trail.length;

            if (i % batchSize === 1 || !started) {
                if (started) {
                    ctx.stroke();
                    ctx.restore();
                }
                const alpha = t * 0.85;
                ctx.save();
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = t * 10;
                ctx.strokeStyle = 'rgba(0,255,136,' + alpha.toFixed(3) + ')';
                ctx.lineWidth = 1 + t * 3;
                ctx.beginPath();
                ctx.moveTo(p0.x, sy0);
                started = true;
            }
            ctx.lineTo(p1.x, sy1);
        }
        if (started) {
            ctx.stroke();
            ctx.restore();
        }
    }

    function drawPlayer() {
        const px = g.px;
        const py = PLAYER_Y;

        ctx.save();
        /* Outer glow */
        ctx.shadowColor = '#00ff88';
        ctx.shadowBlur = 24;
        ctx.fillStyle = '#00ff88';
        ctx.beginPath();
        ctx.arc(px, py, 7, 0, Math.PI * 2);
        ctx.fill();

        /* Middle */
        ctx.shadowBlur = 12;
        ctx.fillStyle = '#aaffcc';
        ctx.beginPath();
        ctx.arc(px, py, 4.5, 0, Math.PI * 2);
        ctx.fill();

        /* Core */
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(px, py, 2.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    /* ===================== Game Loop ===================== */
    function gameLoop() {
        update();
        render();
        if (g.playing) {
            g.raf = requestAnimationFrame(gameLoop);
        }
    }

    /* ===================== Game Over ===================== */
    function gameOver() {
        g.playing = false;
        if (g.raf) cancelAnimationFrame(g.raf);

        updateHighScore();

        const stats = document.getElementById('gameOverStats');
        stats.innerHTML =
            'Level: <span>' + g.level + '</span><br>' +
            'Distance: <span>' + Math.floor(g.dist) + 'm / ' + g.levelLen + 'm</span><br>' +
            'Score: <span>' + g.score + '</span>';
        if (g.score > 0 && g.score >= g.highScore) {
            stats.innerHTML += '<br><span style="color:#ffc107">NEW HIGH SCORE!</span>';
        }

        deathAnimation();
    }

    function deathAnimation() {
        let frame = 0;
        const maxF = 45;
        const dx = g.px, dy = PLAYER_Y;
        const sparks = [];
        for (let i = 0; i < 45; i++) {
            const a = Math.random() * Math.PI * 2;
            const sp = 1.5 + Math.random() * 4.5;
            sparks.push({
                x: dx, y: dy,
                vx: Math.cos(a) * sp,
                vy: Math.sin(a) * sp,
                life: 1,
                s: 1.5 + Math.random() * 3,
                color: Math.random() < 0.5 ? '#ff6b6b' : '#ff9e4a'
            });
        }

        function tick() {
            frame++;
            render();

            const flashA = Math.max(0, 0.35 * (1 - frame / 14));
            ctx.fillStyle = 'rgba(255,107,107,' + flashA.toFixed(3) + ')';
            ctx.fillRect(0, 0, W, H);

            ctx.save();
            for (const s of sparks) {
                s.x += s.vx;
                s.y += s.vy;
                s.vy += 0.06;
                s.life -= 0.022;
                if (s.life <= 0) continue;
                ctx.shadowColor = s.color;
                ctx.shadowBlur = 8;
                ctx.fillStyle = s.color.slice(0, -1) + ',' + s.life.toFixed(2) + ')';
                /* convert hex to rgba inline */
                const r = parseInt(s.color.slice(1, 3), 16);
                const gv = parseInt(s.color.slice(3, 5), 16);
                const b = parseInt(s.color.slice(5, 7), 16);
                ctx.fillStyle = 'rgba(' + r + ',' + gv + ',' + b + ',' + s.life.toFixed(3) + ')';
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.s * s.life, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            if (frame < maxF) {
                requestAnimationFrame(tick);
            } else {
                document.getElementById('gameOverOverlay').classList.add('show');
            }
        }
        tick();
    }

    /* ===================== Level Complete ===================== */
    function levelComplete() {
        g.playing = false;
        if (g.raf) cancelAnimationFrame(g.raf);

        const base = g.level * 1000;
        const speedBonus = Math.round(g.speed * 100);
        const lvScore = base + speedBonus;
        g.score += lvScore;
        document.getElementById('scoreDisp').textContent = g.score;

        updateHighScore();

        const stats = document.getElementById('levelStats');
        stats.innerHTML =
            'Level <span>' + g.level + '</span> cleared!<br>' +
            'Base: <span>+' + base + '</span><br>' +
            'Speed bonus: <span>+' + speedBonus + '</span><br>' +
            'Level total: <span>+' + lvScore + '</span><br>' +
            'Score: <span>' + g.score + '</span>';
        if (g.score >= g.highScore) {
            stats.innerHTML += '<br><span style="color:#ffc107">NEW HIGH SCORE!</span>';
        }

        successAnimation();
    }

    function successAnimation() {
        let frame = 0;
        const maxF = 55;
        const sparkles = [];
        for (let i = 0; i < 60; i++) {
            sparkles.push({
                x: Math.random() * W,
                y: H + Math.random() * 40,
                vx: (Math.random() - 0.5) * 1.5,
                vy: -2 - Math.random() * 4,
                life: 1,
                s: 1.5 + Math.random() * 3.5
            });
        }

        function tick() {
            frame++;
            render();

            const flashA = Math.max(0, 0.25 * (1 - frame / 18));
            ctx.fillStyle = 'rgba(0,255,136,' + flashA.toFixed(3) + ')';
            ctx.fillRect(0, 0, W, H);

            ctx.save();
            for (const s of sparkles) {
                s.x += s.vx;
                s.y += s.vy;
                s.life -= 0.016;
                if (s.life <= 0) continue;
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 7;
                ctx.fillStyle = 'rgba(0,255,136,' + (s.life * 0.7).toFixed(3) + ')';
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.s * s.life, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            if (frame < maxF) {
                requestAnimationFrame(tick);
            } else {
                document.getElementById('levelOverlay').classList.add('show');
            }
        }
        tick();
    }

    function nextLevel() {
        g.level++;
        document.getElementById('levelOverlay').classList.remove('show');
        startGame();
    }

    function resetToMenu() {
        g.level = 1;
        g.score = 0;
        g.playing = false;
        if (g.raf) cancelAnimationFrame(g.raf);

        document.getElementById('scoreDisp').textContent = '0';
        document.getElementById('levelDisp').textContent = '1';
        document.getElementById('progressFill').style.width = '0%';
        document.getElementById('distLabel').textContent = '0m';
        document.getElementById('gameOverOverlay').classList.remove('show');
        document.getElementById('levelOverlay').classList.remove('show');
        document.getElementById('startBtn').style.display = '';

        drawIdle();
    }

    function updateHighScore() {
        if (g.score > g.highScore) {
            g.highScore = g.score;
            localStorage.setItem('lineMazeHighScore', g.highScore);
            document.getElementById('highDisp').textContent = g.highScore;
        }
    }

    let idleRaf = null;
    function drawIdle() {
        ctx.fillStyle = '#050510';
        ctx.fillRect(0, 0, W, H);

        /* Draw a demo corridor */
        ctx.strokeStyle = 'rgba(0,217,255,0.15)';
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 8]);
        const demoTime = Date.now() * 0.001;
        for (let sy = 0; sy < H; sy += 3) {
            const t = sy / H;
            const wave = Math.sin(t * 4 + demoTime) * 60;
            const hw = 80 + Math.sin(t * 2) * 15;
            const cx = W / 2 + wave;
            if (sy === 0) {
                ctx.beginPath();
                ctx.moveTo(cx - hw, sy);
            } else {
                ctx.lineTo(cx - hw, sy);
            }
        }
        ctx.stroke();
        ctx.beginPath();
        for (let sy = 0; sy < H; sy += 3) {
            const t = sy / H;
            const wave = Math.sin(t * 4 + demoTime) * 60;
            const hw = 80 + Math.sin(t * 2) * 15;
            const cx = W / 2 + wave;
            if (sy === 0) ctx.moveTo(cx + hw, sy);
            else ctx.lineTo(cx + hw, sy);
        }
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.fillStyle = 'rgba(0,217,255,0.4)';
        ctx.font = '16px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('Press START to begin', W / 2, H / 2 - 10);
        ctx.fillStyle = 'rgba(0,217,255,0.2)';
        ctx.font = '12px Courier New';
        ctx.fillText('Arrow keys / A D / Touch buttons', W / 2, H / 2 + 14);

        if (!g.playing) idleRaf = requestAnimationFrame(drawIdle);
    }

    /* ===================== Input Handling ===================== */
    const keys = {};

    document.addEventListener('keydown', e => {
        if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'a', 'A', 'd', 'D', 'w', 'W', 's', 'S', ' '].includes(e.key)) {
            e.preventDefault();
        }
        keys[e.key.toLowerCase()] = true;
        updateSteering();

        if (e.key === ' ' && !g.playing) {
            const ovGO = document.getElementById('gameOverOverlay');
            const ovLvl = document.getElementById('levelOverlay');
            if (!ovGO.classList.contains('show') && !ovLvl.classList.contains('show')) {
                startGame();
            }
        }
    });

    document.addEventListener('keyup', e => {
        keys[e.key.toLowerCase()] = false;
        updateSteering();
    });

    function updateSteering() {
        const left = keys['arrowleft'] || keys['a'];
        const right = keys['arrowright'] || keys['d'];
        if (left && !right) g.steering = -1;
        else if (right && !left) g.steering = 1;
        else g.steering = 0;
    }

    /* Touch buttons */
    const btnL = document.getElementById('btnLeft');
    const btnR = document.getElementById('btnRight');

    function bindTouch(btn, dir) {
        btn.addEventListener('touchstart', e => { e.preventDefault(); btn.classList.add('active'); g.steering = dir; }, { passive: false });
        btn.addEventListener('mousedown', e => { e.preventDefault(); btn.classList.add('active'); g.steering = dir; });
    }

    function unbindTouch(btn) {
        ['touchend', 'touchcancel', 'mouseup', 'mouseleave'].forEach(ev => {
            btn.addEventListener(ev, e => {
                e.preventDefault();
                btn.classList.remove('active');
                if (!btnL.classList.contains('active') && !btnR.classList.contains('active')) g.steering = 0;
                else if (btnL.classList.contains('active')) g.steering = -1;
                else g.steering = 1;
            });
        });
    }

    bindTouch(btnL, -1);
    bindTouch(btnR, 1);
    unbindTouch(btnL);
    unbindTouch(btnR);

    /* Canvas touch: left half = left, right half = right */
    let canvasTouchId = null;
    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        const touch = e.changedTouches[0];
        canvasTouchId = touch.identifier;
        const rect = canvas.getBoundingClientRect();
        const tx = (touch.clientX - rect.left) / rect.width;
        g.steering = tx < 0.5 ? -1 : 1;
    }, { passive: false });

    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        for (const touch of e.changedTouches) {
            if (touch.identifier === canvasTouchId) {
                const rect = canvas.getBoundingClientRect();
                const tx = (touch.clientX - rect.left) / rect.width;
                g.steering = tx < 0.5 ? -1 : 1;
            }
        }
    }, { passive: false });

    canvas.addEventListener('touchend', e => {
        e.preventDefault();
        for (const touch of e.changedTouches) {
            if (touch.identifier === canvasTouchId) {
                canvasTouchId = null;
                if (!btnL.classList.contains('active') && !btnR.classList.contains('active')) {
                    g.steering = 0;
                }
            }
        }
    }, { passive: false });

    canvas.addEventListener('touchcancel', e => {
        canvasTouchId = null;
        if (!btnL.classList.contains('active') && !btnR.classList.contains('active')) {
            g.steering = 0;
        }
    });

    /* Start button */
    document.getElementById('startBtn').addEventListener('click', startGame);

    /* ===================== Init ===================== */
    drawIdle();
    </script>
</body>
</html>
