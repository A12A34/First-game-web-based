<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Shooter - Game Hub</title>
    <link rel="stylesheet" href="../css/styles.css">
    <style>
        #gameCanvas {
            border: 3px solid #00d9ff;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 217, 255, 0.3);
            touch-action: none;
            cursor: crosshair;
        }
        .game-stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        .stat-box {
            text-align: center;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            min-width: 80px;
        }
        .stat-label {
            font-size: 0.8rem;
            color: #a0a0a0;
        }
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #00d9ff;
        }
        .fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 8px;
            padding: 10px 15px;
            cursor: pointer;
            font-size: 1.5rem;
            transition: background 0.3s;
        }
        .fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <button id="fullscreenBtn" class="fullscreen-btn" title="Toggle Fullscreen">&#x26F6;</button>
    <div class="container">
        <a href="../index.html" class="back-btn">&larr; Back to Games</a>
        <div class="game-container">
            <h1 class="game-title">Bubble Shooter</h1>

            <div class="game-stats">
                <div class="stat-box">
                    <div class="stat-label">Score</div>
                    <div class="stat-value" id="score">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">High Score</div>
                    <div class="stat-value" id="highScore">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Until Push</div>
                    <div class="stat-value" id="untilPush" style="color:#ff6b6b;">5</div>
                </div>
            </div>

            <canvas id="gameCanvas" width="480" height="640"></canvas>

            <button id="startBtn" class="btn btn-primary" style="margin-top:15px;">New Game</button>

            <div class="instructions">
                <h3>How to Play</h3>
                <p>Move your mouse to aim and click to shoot bubbles upward. Match 3 or more
                bubbles of the same color to pop them. Any bubbles left floating with no
                connection to the ceiling will also fall for bonus points. After every 5 shots
                without popping, the ceiling lowers. The game ends when bubbles cross the
                red danger line.</p>
            </div>
        </div>
    </div>

    <div id="gameOverOverlay" class="game-over-overlay hidden">
        <div class="game-over-content">
            <h2 id="endTitle">Game Over!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button id="playAgainBtn" class="btn btn-primary">Play Again</button>
        </div>
    </div>

    <script>
    (function () {
        /* ===== CANVAS & CONSTANTS ===== */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;   // 480
        const H = canvas.height;  // 640

        const BR = 18;                         // bubble radius
        const BD = BR * 2;                     // bubble diameter
        const RH = BR * Math.sqrt(3);          // row height (~31.18)
        const COLS_E = Math.floor(W / BD);     // 13 columns on even rows
        const COLS_O = COLS_E - 1;             // 12 columns on odd rows
        const MAX_ROWS = 22;
        const INIT_ROWS = 8;
        const SPEED = 14;
        const CX = W / 2;                     // cannon x
        const CY = H - 42;                    // cannon y
        const DANGER = H - 88;                // danger line y
        const PUSH_EVERY = 5;                 // shots before ceiling push
        const MIN_A = -Math.PI + 0.17;
        const MAX_A = -0.17;

        const COL   = ['#ff4444','#44cc44','#4488ff','#ffcc00','#cc44ff','#ff8844'];
        const COL_L = ['#ff9999','#99ff99','#99ccff','#ffee88','#dd99ff','#ffcc99'];
        const COL_D = ['#bb1111','#11aa11','#1155bb','#bb9900','#8811bb','#bb5511'];

        /* ===== STATE ===== */
        let grid, curCol, nxtCol, aim, shot;
        let score, hi, fired, noPop, pushY;
        let running, done;
        let pops, falls, popups;
        let mx, my;

        hi = parseInt(localStorage.getItem('bubbleShooterHi')) || 0;

        /* ===== GRID HELPERS ===== */
        function mc(r)  { return r % 2 === 0 ? COLS_E : COLS_O; }

        function bpos(r, c) {
            return {
                x: BR + c * BD + (r % 2 !== 0 ? BR : 0),
                y: BR + r * RH + pushY
            };
        }

        function nb(r, c) {
            var even = r % 2 === 0;
            var offs = even
                ? [[-1,-1],[-1,0],[0,-1],[0,1],[1,-1],[1,0]]
                : [[-1,0],[-1,1],[0,-1],[0,1],[1,0],[1,1]];
            var res = [];
            for (var i = 0; i < offs.length; i++) {
                var nr = r + offs[i][0], nc = c + offs[i][1];
                if (nr >= 0 && nr < MAX_ROWS && nc >= 0 && nc < mc(nr))
                    res.push([nr, nc]);
            }
            return res;
        }

        function buildGrid() {
            grid = [];
            for (var r = 0; r < MAX_ROWS; r++) {
                var row = new Array(mc(r)).fill(null);
                if (r < INIT_ROWS) {
                    for (var c = 0; c < row.length; c++)
                        row[c] = Math.floor(Math.random() * COL.length);
                }
                grid.push(row);
            }
        }

        function activeCols() {
            var s = new Set();
            for (var r = 0; r < MAX_ROWS; r++)
                for (var c = 0; c < mc(r); c++)
                    if (grid[r][c] !== null) s.add(grid[r][c]);
            return Array.from(s);
        }

        function pickCol() {
            var a = activeCols();
            return a.length ? a[Math.floor(Math.random() * a.length)]
                            : Math.floor(Math.random() * COL.length);
        }

        /* ===== BFS: same-colour cluster ===== */
        function cluster(sr, sc) {
            var color = grid[sr][sc];
            if (color === null) return [];
            var vis = {}, q = [[sr,sc]], res = [];
            vis[sr + ',' + sc] = true;
            while (q.length) {
                var p = q.shift(); var r = p[0], c = p[1];
                res.push(p);
                var ns = nb(r, c);
                for (var i = 0; i < ns.length; i++) {
                    var k = ns[i][0] + ',' + ns[i][1];
                    if (!vis[k] && grid[ns[i][0]][ns[i][1]] === color) {
                        vis[k] = true; q.push(ns[i]);
                    }
                }
            }
            return res;
        }

        /* ===== BFS: find floating (not connected to row 0) ===== */
        function floating() {
            var conn = {}, q = [];
            for (var c = 0; c < mc(0); c++) {
                if (grid[0][c] !== null) { q.push([0,c]); conn['0,' + c] = true; }
            }
            while (q.length) {
                var p = q.shift(); var ns = nb(p[0], p[1]);
                for (var i = 0; i < ns.length; i++) {
                    var k = ns[i][0] + ',' + ns[i][1];
                    if (!conn[k] && grid[ns[i][0]][ns[i][1]] !== null) {
                        conn[k] = true; q.push(ns[i]);
                    }
                }
            }
            var res = [];
            for (var r = 0; r < MAX_ROWS; r++)
                for (var c2 = 0; c2 < mc(r); c2++)
                    if (grid[r][c2] !== null && !conn[r + ',' + c2])
                        res.push([r, c2]);
            return res;
        }

        /* ===== SNAP shot bubble into grid ===== */
        function snap(x, y) {
            var ar = Math.max(0, Math.round((y - BR - pushY) / RH));
            var best = 1e9, br = 0, bc = 0;
            for (var r = Math.max(0, ar - 2); r <= Math.min(MAX_ROWS - 1, ar + 2); r++) {
                for (var c = 0; c < mc(r); c++) {
                    if (grid[r][c] !== null) continue;
                    var p = bpos(r, c);
                    var d = Math.hypot(x - p.x, y - p.y);
                    if (d < best) { best = d; br = r; bc = c; }
                }
            }
            return { row: br, col: bc };
        }

        /* ===== After placing a bubble, resolve matches ===== */
        function resolve(row, col) {
            var cl = cluster(row, col);
            if (cl.length < 3) return false;

            // Pop matched bubbles
            var pts = cl.length * 10;
            for (var i = 0; i < cl.length; i++) {
                var p = bpos(cl[i][0], cl[i][1]);
                pops.push({ x: p.x, y: p.y, ci: grid[cl[i][0]][cl[i][1]], f: 0 });
                grid[cl[i][0]][cl[i][1]] = null;
            }

            // Drop floating bubbles
            var fl = floating();
            var fpts = fl.length * 20;
            for (var j = 0; j < fl.length; j++) {
                var p2 = bpos(fl[j][0], fl[j][1]);
                falls.push({ x: p2.x, y: p2.y, ci: grid[fl[j][0]][fl[j][1]], vy: 0, f: 0 });
                grid[fl[j][0]][fl[j][1]] = null;
            }

            var total = pts + fpts;
            score += total;

            // Score popup at centre of cluster
            var cx2 = 0, cy2 = 0;
            for (var k = 0; k < cl.length; k++) {
                var pp = bpos(cl[k][0], cl[k][1]);
                cx2 += pp.x; cy2 += pp.y;
            }
            popups.push({ x: cx2 / cl.length, y: cy2 / cl.length, txt: '+' + total, f: 0 });

            noPop = 0;

            // Board cleared bonus
            if (activeCols().length === 0) {
                score += 1000;
                popups.push({ x: W / 2, y: H / 2, txt: 'CLEAR +1000', f: 0 });
                buildGrid();
                pushY = 0;
            }
            ui();
            return true;
        }

        /* ===== SHOOTING ===== */
        function shoot() {
            if (!running || done || shot || pops.length || falls.length) return;
            shot = {
                x: CX, y: CY,
                dx: Math.cos(aim) * SPEED,
                dy: Math.sin(aim) * SPEED,
                ci: curCol
            };
            fired++;
        }

        function movShot() {
            if (!shot) return;
            shot.x += shot.dx;
            shot.y += shot.dy;

            // Wall bounce
            if (shot.x < BR) { shot.x = 2 * BR - shot.x; shot.dx = -shot.dx; }
            if (shot.x > W - BR) { shot.x = 2 * (W - BR) - shot.x; shot.dx = -shot.dx; }

            // Ceiling hit
            if (shot.y - BR <= pushY) { place(); return; }

            // Collision with grid bubbles (check nearby rows)
            var ar = Math.max(0, Math.round((shot.y - BR - pushY) / RH));
            for (var r = Math.max(0, ar - 3); r <= Math.min(MAX_ROWS - 1, ar + 3); r++) {
                for (var c = 0; c < mc(r); c++) {
                    if (grid[r][c] === null) continue;
                    var p = bpos(r, c);
                    if (Math.hypot(shot.x - p.x, shot.y - p.y) < BD - 2) {
                        place(); return;
                    }
                }
            }

            // Safety: out of canvas
            if (shot.y > H + BR) { shot = null; curCol = nxtCol; nxtCol = pickCol(); }
        }

        function place() {
            var s = snap(shot.x, shot.y);
            grid[s.row][s.col] = shot.ci;

            var popped = resolve(s.row, s.col);
            if (!popped) {
                noPop++;
                if (noPop >= PUSH_EVERY) {
                    pushY += RH;
                    noPop = 0;
                }
            }

            shot = null;
            curCol = nxtCol;
            nxtCol = pickCol();
            ui();
            checkEnd();
        }

        function checkEnd() {
            for (var r = 0; r < MAX_ROWS; r++)
                for (var c = 0; c < mc(r); c++)
                    if (grid[r][c] !== null) {
                        var p = bpos(r, c);
                        if (p.y > DANGER) { endGame(); return; }
                    }
        }

        function endGame() {
            running = false; done = true;
            if (score > hi) {
                hi = score;
                localStorage.setItem('bubbleShooterHi', hi);
            }
            document.getElementById('highScore').textContent = hi;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('endTitle').textContent =
                activeCols().length === 0 ? 'You Win!' : 'Game Over!';
            document.getElementById('gameOverOverlay').classList.remove('hidden');
        }

        /* ===== DRAWING ===== */
        function drawBubble(x, y, ci, radius, alpha) {
            if (alpha === undefined) alpha = 1;
            ctx.globalAlpha = alpha;
            var g = ctx.createRadialGradient(x - radius * 0.3, y - radius * 0.3, radius * 0.08, x, y, radius);
            g.addColorStop(0, COL_L[ci]);
            g.addColorStop(0.6, COL[ci]);
            g.addColorStop(1, COL_D[ci]);
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = g;
            ctx.fill();
            // Shine highlight
            ctx.beginPath();
            ctx.arc(x - radius * 0.28, y - radius * 0.3, radius * 0.22, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255,255,255,' + (0.45 * alpha) + ')';
            ctx.fill();
            ctx.globalAlpha = 1;
        }

        function drawGrid() {
            for (var r = 0; r < MAX_ROWS; r++)
                for (var c = 0; c < mc(r); c++) {
                    if (grid[r][c] === null) continue;
                    var p = bpos(r, c);
                    if (p.y > -BR && p.y < H + BR) drawBubble(p.x, p.y, grid[r][c], BR);
                }
        }

        function drawGuide() {
            if (shot || !running || pops.length || falls.length) return;
            var x = CX, y = CY;
            var dx = Math.cos(aim), dy = Math.sin(aim);
            ctx.save();
            ctx.setLineDash([5, 10]);
            ctx.strokeStyle = 'rgba(255,255,255,0.22)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y);
            var step = 4, maxD = 900, d = 0, hit = false;
            while (d < maxD && !hit) {
                x += dx * step; y += dy * step; d += step;
                if (x < BR) { x = 2 * BR - x; dx = -dx; }
                if (x > W - BR) { x = 2 * (W - BR) - x; dx = -dx; }
                if (y - BR <= pushY) hit = true;
                if (!hit) {
                    var ar = Math.max(0, Math.round((y - BR - pushY) / RH));
                    for (var r = Math.max(0, ar - 1); r <= Math.min(MAX_ROWS - 1, ar + 1) && !hit; r++)
                        for (var c = 0; c < mc(r) && !hit; c++)
                            if (grid[r][c] !== null && Math.hypot(x - bpos(r,c).x, y - bpos(r,c).y) < BD - 2)
                                hit = true;
                }
                ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.restore();
            // Endpoint circle
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255,255,255,0.35)';
            ctx.fill();
        }

        function drawCannon() {
            // Base
            ctx.fillStyle = '#222244';
            ctx.beginPath();
            ctx.arc(CX, CY + 8, 28, Math.PI, 0);
            ctx.fill();
            ctx.fillRect(CX - 28, CY + 8, 56, 12);

            // Barrel
            ctx.save();
            ctx.translate(CX, CY);
            ctx.rotate(aim + Math.PI / 2);
            ctx.fillStyle = '#3a3a5e';
            ctx.fillRect(-5, 0, 10, -42);
            ctx.strokeStyle = '#5a5a7e';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(-5, 0, 10, -42);
            ctx.restore();

            // Current bubble in cannon
            drawBubble(CX, CY, curCol, BR);

            // Next bubble preview
            ctx.fillStyle = '#888';
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('NEXT', CX + 58, CY - 14);
            drawBubble(CX + 58, CY + 4, nxtCol, BR * 0.65);
            ctx.textAlign = 'left';
        }

        function drawDanger() {
            ctx.save();
            ctx.setLineDash([8, 6]);
            ctx.strokeStyle = 'rgba(255,60,60,0.35)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, DANGER);
            ctx.lineTo(W, DANGER);
            ctx.stroke();
            ctx.restore();
            // Subtle danger zone fill
            ctx.fillStyle = 'rgba(255,40,40,0.06)';
            ctx.fillRect(0, DANGER, W, H - DANGER);
        }

        function drawPushIndicator() {
            // Small dots top-right showing shots remaining until push
            var left = PUSH_EVERY - noPop;
            for (var i = 0; i < PUSH_EVERY; i++) {
                ctx.beginPath();
                ctx.arc(W - 14 - i * 14, 14, 4, 0, Math.PI * 2);
                ctx.fillStyle = i < noPop ? '#ff4444' : 'rgba(255,255,255,0.15)';
                ctx.fill();
            }
        }

        function drawAnims() {
            // Pop animations
            for (var i = pops.length - 1; i >= 0; i--) {
                var a = pops[i];
                var t = a.f / 20;
                // Ring
                ctx.beginPath();
                ctx.arc(a.x, a.y, BR + t * 22, 0, Math.PI * 2);
                ctx.strokeStyle = COL[a.ci];
                ctx.lineWidth = 3 * (1 - t);
                ctx.globalAlpha = 1 - t;
                ctx.stroke();
                ctx.globalAlpha = 1;
                // Shrinking bubble
                if (t < 0.5)
                    drawBubble(a.x, a.y, a.ci, BR * (1 - t * 2), 1 - t * 2);
                // Particles
                for (var p = 0; p < 6; p++) {
                    var ang = (p / 6) * Math.PI * 2 + a.f * 0.05;
                    var px = a.x + Math.cos(ang) * t * 28;
                    var py = a.y + Math.sin(ang) * t * 28;
                    ctx.beginPath();
                    ctx.arc(px, py, 2.5 * (1 - t), 0, Math.PI * 2);
                    ctx.fillStyle = COL[a.ci];
                    ctx.globalAlpha = 1 - t;
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
                a.f++;
                if (a.f >= 20) pops.splice(i, 1);
            }
            // Fall animations
            for (var j = falls.length - 1; j >= 0; j--) {
                var b = falls[j];
                b.vy += 0.6;
                b.y += b.vy;
                b.x += (Math.random() - 0.5) * 1.5;
                var al = Math.max(0, 1 - Math.max(0, b.y - DANGER) / (H - DANGER + 50));
                if (b.y < H + BR * 2) drawBubble(b.x, b.y, b.ci, BR, al);
                b.f++;
                if (b.y > H + BR * 3) falls.splice(j, 1);
            }
            // Score popups
            for (var k = popups.length - 1; k >= 0; k--) {
                var sp = popups[k];
                var prog = sp.f / 45;
                ctx.fillStyle = 'rgba(255,255,255,' + (1 - prog) + ')';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(sp.txt, sp.x, sp.y - prog * 45);
                ctx.textAlign = 'left';
                sp.f++;
                if (sp.f >= 45) popups.splice(k, 1);
            }
        }

        function draw() {
            // Background
            ctx.fillStyle = '#0a0a1e';
            ctx.fillRect(0, 0, W, H);

            // Ceiling zone
            if (pushY > 0) {
                ctx.fillStyle = '#0d0d26';
                ctx.fillRect(0, 0, W, pushY);
                ctx.strokeStyle = 'rgba(0,217,255,0.25)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, pushY);
                ctx.lineTo(W, pushY);
                ctx.stroke();
            }

            drawDanger();
            drawGrid();
            drawGuide();

            if (shot) drawBubble(shot.x, shot.y, shot.ci, BR);

            drawAnims();
            drawCannon();
            drawPushIndicator();

            // Pre-game overlay
            if (!running && !done) {
                ctx.fillStyle = 'rgba(0,0,0,0.55)';
                ctx.fillRect(0, 0, W, H);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('BUBBLE SHOOTER', W / 2, H / 2 - 20);
                ctx.font = '16px Arial';
                ctx.fillStyle = '#aaa';
                ctx.fillText('Click "New Game" to start', W / 2, H / 2 + 18);
                ctx.textAlign = 'left';
            }
        }

        /* ===== LOOP ===== */
        function update() {
            if (!running) return;
            movShot();
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        /* ===== GAME CONTROL ===== */
        function startGame() {
            buildGrid();
            pushY = 0;
            score = 0; fired = 0; noPop = 0;
            shot = null; pops = []; falls = []; popups = [];
            done = false; running = true;
            curCol = pickCol(); nxtCol = pickCol();
            aim = -Math.PI / 2;
            document.getElementById('gameOverOverlay').classList.add('hidden');
            ui();
        }

        function ui() {
            document.getElementById('score').textContent = score;
            document.getElementById('highScore').textContent = hi;
            document.getElementById('untilPush').textContent = PUSH_EVERY - noPop;
        }

        /* ===== INPUT ===== */
        function aimFrom(px, py) {
            aim = Math.atan2(py - CY, px - CX);
            if (aim > 0) aim = aim < Math.PI / 2 ? MAX_A : MIN_A;
            aim = Math.max(MIN_A, Math.min(MAX_A, aim));
        }

        canvas.addEventListener('mousemove', function (e) {
            var r = canvas.getBoundingClientRect();
            mx = (e.clientX - r.left) * (W / r.width);
            my = (e.clientY - r.top) * (H / r.height);
            aimFrom(mx, my);
        });

        canvas.addEventListener('click', function () { shoot(); });

        canvas.addEventListener('touchstart', function (e) {
            e.preventDefault();
            var t = e.touches[0], r = canvas.getBoundingClientRect();
            aimFrom((t.clientX - r.left) * (W / r.width),
                    (t.clientY - r.top) * (H / r.height));
        });

        canvas.addEventListener('touchmove', function (e) {
            e.preventDefault();
            var t = e.touches[0], r = canvas.getBoundingClientRect();
            aimFrom((t.clientX - r.left) * (W / r.width),
                    (t.clientY - r.top) * (H / r.height));
        });

        canvas.addEventListener('touchend', function (e) {
            e.preventDefault();
            shoot();
        });

        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('playAgainBtn').addEventListener('click', function () {
            document.getElementById('gameOverOverlay').classList.add('hidden');
            startGame();
        });

        document.getElementById('fullscreenBtn').addEventListener('click', function () {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });

        /* ===== INIT ===== */
        buildGrid();
        pushY = 0; score = 0; fired = 0; noPop = 0;
        shot = null; pops = []; falls = []; popups = [];
        done = false; running = false;
        curCol = pickCol(); nxtCol = pickCol();
        aim = -Math.PI / 2;
        mx = CX; my = 0;
        ui();
        loop();
    })();
    </script>
    <script src="../js/accounts.js"></script>
</body>
</html>
