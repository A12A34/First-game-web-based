<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense - Game Hub</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../css/styles.css">
    <style>
        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        canvas {
            border: 3px solid #333;
            border-radius: 10px;
            background: #2d4a1c;
            cursor: crosshair;
        }
        .stats-bar {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .stat-box {
            text-align: center;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        .stat-value {
            font-size: 1.3rem;
            font-weight: bold;
        }
        .stat-value.gold { color: #ffd700; }
        .stat-value.lives { color: #ff6b6b; }
        .stat-value.wave { color: #00ff88; }
        .stat-value.score { color: #bb88ff; }
        .stat-label {
            font-size: 0.7rem;
            color: #888;
        }
        .towers {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .tower-btn {
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            min-width: 65px;
        }
        .tower-btn:hover:not(.selected):not(:disabled) {
            border-color: #ffd700;
            transform: scale(1.05);
        }
        .tower-btn.selected {
            background: #ffd700;
            color: #000;
            border-color: #ffd700;
        }
        .tower-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .tower-icon {
            font-size: 1.3rem;
        }
        .tower-name {
            font-size: 0.7rem;
            font-weight: bold;
        }
        .tower-cost {
            font-size: 0.65rem;
            color: #ffd700;
        }
        .tower-btn.selected .tower-cost {
            color: #886600;
        }
        .message {
            font-size: 1rem;
            min-height: 24px;
            color: #ffaa00;
        }
        .controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }
        .controls .btn {
            padding: 8px 16px;
            font-size: 0.85rem;
        }
        .btn-speed {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 8px 14px;
            cursor: pointer;
            color: #fff;
            font-size: 0.85rem;
            transition: all 0.2s;
        }
        .btn-speed:hover { background: rgba(255, 255, 255, 0.25); }
        .btn-speed.active {
            background: #ffd700;
            color: #000;
            border-color: #ffd700;
        }
        .info-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.92);
            border: 1px solid #ffd700;
            border-radius: 8px;
            padding: 10px;
            pointer-events: none;
            font-size: 0.75rem;
            line-height: 1.4;
            z-index: 100;
            min-width: 170px;
        }
        .info-panel .title { color: #ffd700; font-weight: bold; font-size: 0.85rem; }
        .info-panel .stat { color: #ccc; }
        .info-panel .stat span { color: #fff; font-weight: bold; }
        .info-panel .upgrade { color: #00ff88; margin-top: 4px; }
        .info-panel .upgrade-path { color: #00ccff; font-size: 0.7rem; }
        .info-panel .sell { color: #ff6b6b; }
        .upgrade-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ffd700;
            border-radius: 12px;
            padding: 12px;
            z-index: 200;
            min-width: 220px;
            pointer-events: auto;
        }
        .upgrade-panel .title { color: #ffd700; font-weight: bold; font-size: 0.9rem; margin-bottom: 8px; }
        .upgrade-option {
            padding: 8px 10px;
            margin: 4px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid rgba(255,255,255,0.15);
        }
        .upgrade-option:hover:not(.locked) {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }
        .upgrade-option.locked {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .upgrade-option .opt-name { color: #00ff88; font-weight: bold; font-size: 0.8rem; }
        .upgrade-option .opt-desc { color: #aaa; font-size: 0.7rem; }
        .upgrade-option .opt-cost { color: #ffd700; font-size: 0.7rem; font-weight: bold; }
        .upgrade-close {
            margin-top: 6px;
            padding: 4px 12px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            color: #aaa;
            cursor: pointer;
            font-size: 0.7rem;
            display: block;
            width: 100%;
        }
        .upgrade-close:hover { background: rgba(255,255,255,0.2); }
        .wave-preview {
            font-size: 0.8rem;
            color: #aaa;
            text-align: center;
        }
        .wave-preview span { color: #fff; font-weight: bold; }
        .fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 8px;
            padding: 10px 15px;
            cursor: pointer;
            font-size: 1.5rem;
        }
        .canvas-wrapper {
            position: relative;
            display: inline-block;
        }
        .instructions {
            max-width: 900px;
        }
        .instructions table {
            width: 100%;
            border-collapse: collapse;
            margin: 8px 0;
            font-size: 0.75rem;
        }
        .instructions th, .instructions td {
            padding: 4px 6px;
            text-align: center;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .instructions th { color: #ffd700; }
        .enemy-legend { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; margin: 8px 0; font-size: 0.78rem; }
        .enemy-legend-item { display: flex; align-items: center; gap: 4px; }
    </style>
</head>
<body>
    <button id="fullscreenBtn" class="fullscreen-btn" title="Toggle Fullscreen">&#x26F6;</button>
    <div class="container">
        <a href="../index.html" class="back-btn">&larr; Back to Games</a>

        <div class="game-container">
            <h1 class="game-title">Tower Defense</h1>

            <div class="game-area">
                <div class="stats-bar">
                    <div class="stat-box">
                        <div class="stat-value gold" id="gold">200</div>
                        <div class="stat-label">Gold</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value lives" id="lives">20</div>
                        <div class="stat-label">Lives</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value wave" id="wave">0</div>
                        <div class="stat-label">Wave</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value score" id="score">0</div>
                        <div class="stat-label">Score</div>
                    </div>
                </div>

                <div class="towers">
                    <button class="tower-btn" data-tower="arrow">
                        <div class="tower-icon">&#x1F3F9;</div>
                        <div class="tower-name">Arrow</div>
                        <div class="tower-cost">50g</div>
                    </button>
                    <button class="tower-btn" data-tower="cannon">
                        <div class="tower-icon">&#x1F4A3;</div>
                        <div class="tower-name">Cannon</div>
                        <div class="tower-cost">100g</div>
                    </button>
                    <button class="tower-btn" data-tower="ice">
                        <div class="tower-icon">&#x2744;&#xFE0F;</div>
                        <div class="tower-name">Ice</div>
                        <div class="tower-cost">75g</div>
                    </button>
                    <button class="tower-btn" data-tower="fire">
                        <div class="tower-icon">&#x1F525;</div>
                        <div class="tower-name">Fire</div>
                        <div class="tower-cost">150g</div>
                    </button>
                    <button class="tower-btn" data-tower="lightning">
                        <div class="tower-icon">&#x26A1;</div>
                        <div class="tower-name">Lightning</div>
                        <div class="tower-cost">200g</div>
                    </button>
                    <button class="tower-btn" data-tower="poison">
                        <div class="tower-icon">&#x2622;&#xFE0F;</div>
                        <div class="tower-name">Poison</div>
                        <div class="tower-cost">125g</div>
                    </button>
                    <button class="tower-btn" data-tower="sniper">
                        <div class="tower-icon">&#x1F3AF;</div>
                        <div class="tower-name">Sniper</div>
                        <div class="tower-cost">175g</div>
                    </button>
                    <button class="tower-btn" data-tower="tesla">
                        <div class="tower-icon">&#x1F50C;</div>
                        <div class="tower-name">Tesla</div>
                        <div class="tower-cost">250g</div>
                    </button>
                </div>

                <div class="canvas-wrapper">
                    <canvas id="gameCanvas" width="900" height="600"></canvas>
                    <div class="info-panel" id="infoPanel" style="display:none;"></div>
                    <div class="upgrade-panel" id="upgradePanel" style="display:none;"></div>
                </div>

                <div class="message" id="message">Select a tower and click on grass to place it!</div>

                <div class="wave-preview" id="wavePreview"></div>

                <div class="controls">
                    <button id="startWaveBtn" class="btn btn-primary">Start Wave</button>
                    <button id="pauseBtn" class="btn-speed">Pause</button>
                    <button id="speedBtn" class="btn-speed" title="Toggle speed">1x</button>
                    <button id="newGameBtn" class="btn btn-secondary">New Game</button>
                </div>
            </div>

            <div class="instructions">
                <h3>How to Play</h3>
                <p>Build and upgrade towers to stop enemies from reaching the end of the path. Earn gold by defeating enemies and completing waves!</p>
                <p><strong>Left-click</strong> grass to place towers. <strong>Left-click</strong> an existing tower to open upgrade paths. <strong>Right-click</strong> a tower to sell it for 60% of total cost.</p>

                <h4>Towers</h4>
                <table>
                    <tr><th>Tower</th><th>Cost</th><th>Damage</th><th>Range</th><th>Speed</th><th>Special</th></tr>
                    <tr><td>Arrow</td><td>50g</td><td>10</td><td>120px</td><td>Fast</td><td>Long range</td></tr>
                    <tr><td>Cannon</td><td>100g</td><td>35</td><td>90px</td><td>Slow</td><td>Splash damage</td></tr>
                    <tr><td>Ice</td><td>75g</td><td>5</td><td>100px</td><td>Medium</td><td>Slows 50%</td></tr>
                    <tr><td>Fire</td><td>150g</td><td>20</td><td>80px</td><td>Very Fast</td><td>Burn DOT</td></tr>
                    <tr><td>Lightning</td><td>200g</td><td>15</td><td>110px</td><td>Medium</td><td>Chain 3 targets</td></tr>
                    <tr><td>Poison</td><td>125g</td><td>8</td><td>95px</td><td>Medium</td><td>Poison AOE</td></tr>
                    <tr><td>Sniper</td><td>175g</td><td>60</td><td>200px</td><td>Very Slow</td><td>Crit chance</td></tr>
                    <tr><td>Tesla</td><td>250g</td><td>25</td><td>100px</td><td>Medium</td><td>Hits all in range</td></tr>
                </table>
                <p style="font-size:0.78rem;color:#aaa;">Each tower has two upgrade paths: one focused on <span style="color:#ff6b6b;">Power</span> and one on <span style="color:#00ccff;">Range/Utility</span>. Choose wisely - you can mix paths!</p>

                <h4>Enemies</h4>
                <div class="enemy-legend">
                    <div class="enemy-legend-item"><span style="color:#ff4444">&#x25CF;</span> Normal</div>
                    <div class="enemy-legend-item"><span style="color:#44ff44">&#x25CF;</span> Fast (2x speed)</div>
                    <div class="enemy-legend-item"><span style="color:#8888ff">&#x25CF;</span> Armored (3x HP)</div>
                    <div class="enemy-legend-item"><span style="color:#ff44ff">&#x25CF;</span> Boss (10x HP)</div>
                    <div class="enemy-legend-item"><span style="color:#44ffcc">&#x25CF;</span> Healer (heals nearby)</div>
                    <div class="enemy-legend-item"><span style="color:#888888">&#x25CF;</span> Stealth (invisible)</div>
                    <div class="enemy-legend-item"><span style="color:#ffff44">&#x25CF;</span> Swarm (many, weak)</div>
                    <div class="enemy-legend-item"><span style="color:#ff8844">&#x25CF;</span> Shield (has barrier)</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const TILE = 40;
        const COLS = Math.floor(canvas.width / TILE);
        const ROWS = Math.floor(canvas.height / TILE);

        // Tower definitions with dual upgrade paths
        const TOWER_DATA = {
            arrow: {
                cost: 50, damage: 10, range: 120, rate: 400, color: '#8b6914',
                upgradePaths: {
                    power: [
                        { cost: 40, label: 'Sharp Tips', desc: 'Dmg 10→18, +pierce', damage: 18, rate: 380, pierce: true },
                        { cost: 80, label: 'Flame Arrows', desc: 'Dmg 18→30, adds burn', damage: 30, rate: 350, burn: 3, burnDuration: 1500 },
                        { cost: 160, label: 'Volley', desc: 'Dmg 30→22 but fires 3 arrows', damage: 22, rate: 300, multishot: 3 }
                    ],
                    range: [
                        { cost: 35, label: 'Long Bow', desc: 'Range 120→150', range: 150, rate: 380 },
                        { cost: 70, label: 'Eagle Eye', desc: 'Range 150→190, reveals stealth', range: 190, rate: 350, detectStealth: true },
                        { cost: 140, label: 'Marksman', desc: 'Range 190→230, +crit 20%', range: 230, rate: 320, crit: 0.2, critMult: 2.5 }
                    ]
                }
            },
            cannon: {
                cost: 100, damage: 35, range: 90, rate: 1200, color: '#555', splash: 50,
                upgradePaths: {
                    power: [
                        { cost: 75, label: 'Heavy Shell', desc: 'Dmg 35→60, splash 50→65', damage: 60, splash: 65 },
                        { cost: 150, label: 'Cluster Bomb', desc: 'Dmg 60→85, splash 65→85', damage: 85, splash: 85, rate: 1100 },
                        { cost: 250, label: 'Mega Bomb', desc: 'Dmg 85→140, splash 85→110', damage: 140, splash: 110, rate: 1000 }
                    ],
                    range: [
                        { cost: 60, label: 'Long Barrel', desc: 'Range 90→110, rate faster', range: 110, rate: 1050 },
                        { cost: 120, label: 'Mortar', desc: 'Range 110→140, stuns 0.5s', range: 140, rate: 1000, stun: 500 },
                        { cost: 200, label: 'Artillery', desc: 'Range 140→180, stuns 1s', range: 180, rate: 950, stun: 1000 }
                    ]
                }
            },
            ice: {
                cost: 75, damage: 5, range: 100, rate: 600, color: '#00bfff', slow: 0.5, slowDuration: 1500,
                upgradePaths: {
                    power: [
                        { cost: 60, label: 'Deep Freeze', desc: 'Slow 50%→60%, dmg 5→12', damage: 12, slow: 0.4, slowDuration: 2000 },
                        { cost: 120, label: 'Permafrost', desc: 'Slow 60%→75%, dmg 12→20', damage: 20, slow: 0.25, slowDuration: 2500, rate: 550 },
                        { cost: 200, label: 'Absolute Zero', desc: 'Freeze nearby for 1s', damage: 25, slow: 0.1, slowDuration: 3000, rate: 500, freezeAOE: 60 }
                    ],
                    range: [
                        { cost: 50, label: 'Frost Field', desc: 'Range 100→125', range: 125, damage: 8, rate: 550 },
                        { cost: 100, label: 'Blizzard', desc: 'Range 125→155, AOE slow', range: 155, damage: 12, slowAOE: 80, rate: 500 },
                        { cost: 180, label: 'Ice Storm', desc: 'Range 155→185, bigger AOE', range: 185, damage: 18, slowAOE: 110, rate: 450 }
                    ]
                }
            },
            fire: {
                cost: 150, damage: 20, range: 80, rate: 350, color: '#ff4500', burn: 5, burnDuration: 2000,
                upgradePaths: {
                    power: [
                        { cost: 100, label: 'Inferno', desc: 'Dmg 20→32, burn 5→10', damage: 32, burn: 10, burnDuration: 2500, rate: 320 },
                        { cost: 180, label: 'Hellfire', desc: 'Dmg 32→48, burn 10→16', damage: 48, burn: 16, burnDuration: 3000, rate: 280 },
                        { cost: 300, label: 'Phoenix', desc: 'Dmg 48→65, burn spreads', damage: 65, burn: 20, burnDuration: 3500, rate: 250, burnSpread: true }
                    ],
                    range: [
                        { cost: 80, label: 'Napalm', desc: 'Range 80→100, +fire trail', range: 100, damage: 25, burn: 7, burnDuration: 2200 },
                        { cost: 160, label: 'Firestorm', desc: 'Range 100→120, fire AOE', range: 120, damage: 30, burn: 10, burnDuration: 2500, fireAOE: 60 },
                        { cost: 260, label: 'Meteor', desc: 'Range 120→140, massive AOE', range: 140, damage: 40, burn: 14, burnDuration: 3000, fireAOE: 90, rate: 300 }
                    ]
                }
            },
            lightning: {
                cost: 200, damage: 15, range: 110, rate: 700, color: '#ffff00', chain: 3,
                upgradePaths: {
                    power: [
                        { cost: 150, label: 'High Voltage', desc: 'Dmg 15→28, chain 3→4', damage: 28, chain: 4, rate: 650 },
                        { cost: 250, label: 'Thunder', desc: 'Dmg 28→45, chain 4→5', damage: 45, chain: 5, rate: 600 },
                        { cost: 400, label: 'Storm Lord', desc: 'Dmg 45→65, chain 5→7', damage: 65, chain: 7, rate: 550 }
                    ],
                    range: [
                        { cost: 120, label: 'Conductor', desc: 'Range 110→135, chain range+', range: 135, damage: 20, chain: 4 },
                        { cost: 220, label: 'Tesla Field', desc: 'Range 135→160, stuns 0.3s', range: 160, damage: 30, chain: 5, stun: 300 },
                        { cost: 350, label: 'Ion Cannon', desc: 'Range 160→190, reveals stealth', range: 190, damage: 40, chain: 6, stun: 500, detectStealth: true }
                    ]
                }
            },
            poison: {
                cost: 125, damage: 8, range: 95, rate: 700, color: '#00cc44', poisonAOE: 55, poisonDmg: 4, poisonDuration: 3000,
                upgradePaths: {
                    power: [
                        { cost: 80, label: 'Toxic', desc: 'Poison 4→8 dps, dmg 8→14', damage: 14, poisonDmg: 8, poisonDuration: 3500 },
                        { cost: 160, label: 'Plague', desc: 'Poison 8→14 dps, weakens armor', damage: 20, poisonDmg: 14, poisonDuration: 4000, armorShred: 0.2 },
                        { cost: 280, label: 'Bio Weapon', desc: 'Poison 14→22 dps, -30% armor', damage: 28, poisonDmg: 22, poisonDuration: 5000, armorShred: 0.3, rate: 600 }
                    ],
                    range: [
                        { cost: 65, label: 'Wide Spray', desc: 'AOE 55→75, range 95→110', range: 110, poisonAOE: 75, damage: 10 },
                        { cost: 130, label: 'Gas Cloud', desc: 'AOE 75→100, range 110→130', range: 130, poisonAOE: 100, damage: 14, poisonDuration: 3500 },
                        { cost: 230, label: 'Miasma', desc: 'AOE 100→130, slows 30%', range: 145, poisonAOE: 130, damage: 18, poisonDuration: 4000, slow: 0.7, slowDuration: 1500 }
                    ]
                }
            },
            sniper: {
                cost: 175, damage: 60, range: 200, rate: 2000, color: '#aa4400', crit: 0.15, critMult: 3,
                upgradePaths: {
                    power: [
                        { cost: 120, label: 'Hollow Point', desc: 'Dmg 60→100, crit 15%→25%', damage: 100, crit: 0.25 },
                        { cost: 220, label: 'Armor Piercing', desc: 'Dmg 100→150, ignores armor', damage: 150, crit: 0.3, armorPierce: true },
                        { cost: 380, label: 'Railgun', desc: 'Dmg 150→250, crit 30%→40%', damage: 250, crit: 0.4, armorPierce: true, rate: 1800 }
                    ],
                    range: [
                        { cost: 100, label: 'Scope', desc: 'Range 200→250, rate faster', range: 250, rate: 1800 },
                        { cost: 200, label: 'Spotter', desc: 'Range 250→300, detects stealth', range: 300, rate: 1600, detectStealth: true },
                        { cost: 350, label: 'Orbital', desc: 'Range 300→400, biggest range', range: 400, rate: 1500, detectStealth: true, damage: 80 }
                    ]
                }
            },
            tesla: {
                cost: 250, damage: 25, range: 100, rate: 800, color: '#cc44ff', hitsAll: true,
                upgradePaths: {
                    power: [
                        { cost: 180, label: 'Overcharge', desc: 'Dmg 25→40, shocks enemies', damage: 40, stun: 200, rate: 750 },
                        { cost: 300, label: 'Surge', desc: 'Dmg 40→60, longer stun', damage: 60, stun: 400, rate: 700 },
                        { cost: 450, label: 'Singularity', desc: 'Dmg 60→90, pulls enemies in', damage: 90, stun: 600, rate: 650, pull: true }
                    ],
                    range: [
                        { cost: 150, label: 'Amplifier', desc: 'Range 100→125', range: 125, damage: 30, rate: 750 },
                        { cost: 280, label: 'Field Gen', desc: 'Range 125→155, reveals stealth', range: 155, damage: 40, rate: 700, detectStealth: true },
                        { cost: 420, label: 'Reactor', desc: 'Range 155→185, boosts nearby', range: 185, damage: 50, rate: 650, detectStealth: true, boostNearby: 0.2 }
                    ]
                }
            }
        };

        // Enemy types (original 4 + 4 new)
        const ENEMY_TYPES = {
            normal:  { color: '#ff4444', speedMult: 1,   healthMult: 1,   reward: 1,   radius: 10 },
            fast:    { color: '#44ff44', speedMult: 2,   healthMult: 0.6, reward: 1.2, radius: 8 },
            armored: { color: '#8888ff', speedMult: 0.6, healthMult: 3,   reward: 2,   radius: 13 },
            boss:    { color: '#ff44ff', speedMult: 0.4, healthMult: 10,  reward: 10,  radius: 18 },
            healer:  { color: '#44ffcc', speedMult: 0.7, healthMult: 1.5, reward: 3,   radius: 11, heals: true },
            stealth: { color: '#888888', speedMult: 1.4, healthMult: 0.8, reward: 2.5, radius: 9,  stealthy: true },
            swarm:   { color: '#ffff44', speedMult: 1.6, healthMult: 0.3, reward: 0.5, radius: 6 },
            shield:  { color: '#ff8844', speedMult: 0.8, healthMult: 2,   reward: 3,   radius: 12, hasShield: true }
        };

        // Map data
        const MAP = [];
        const PATH = [];

        function generateMap() {
            MAP.length = 0;
            PATH.length = 0;
            for (let y = 0; y < ROWS; y++) {
                MAP.push(new Array(COLS).fill(0));
            }

            const MAPS = [
                [
                    {x:0,y:2},{x:5,y:2},{x:5,y:5},{x:1,y:5},
                    {x:1,y:8},{x:7,y:8},{x:7,y:3},{x:10,y:3},
                    {x:10,y:10},{x:14,y:10},{x:14,y:6},{x:11,y:6},
                    {x:11,y:1},{x:17,y:1},{x:17,y:7},{x:20,y:7},
                    {x:20,y:3},{x:21,y:3}
                ],
                [
                    {x:0,y:0},{x:20,y:0},{x:20,y:13},{x:2,y:13},
                    {x:2,y:2},{x:18,y:2},{x:18,y:11},{x:4,y:11},
                    {x:4,y:4},{x:16,y:4},{x:16,y:9},{x:6,y:9},
                    {x:6,y:6},{x:14,y:6},{x:14,y:7},{x:10,y:7}
                ],
                [
                    {x:0,y:7},{x:4,y:7},{x:4,y:1},{x:8,y:1},
                    {x:8,y:13},{x:12,y:13},{x:12,y:1},{x:16,y:1},
                    {x:16,y:13},{x:20,y:13},{x:20,y:7},{x:21,y:7}
                ]
            ];
            const waypoints = MAPS[mapIndex];

            for (let w = 0; w < waypoints.length - 1; w++) {
                const from = waypoints[w];
                const to = waypoints[w + 1];
                let cx = from.x, cy = from.y;
                while (cx !== to.x) {
                    if (cx >= 0 && cx < COLS && cy >= 0 && cy < ROWS) {
                        MAP[cy][cx] = 1;
                        if (PATH.length === 0 || PATH[PATH.length-1].x !== cx || PATH[PATH.length-1].y !== cy) {
                            PATH.push({x:cx, y:cy});
                        }
                    }
                    cx += cx < to.x ? 1 : -1;
                }
                while (cy !== to.y) {
                    if (cx >= 0 && cx < COLS && cy >= 0 && cy < ROWS) {
                        MAP[cy][cx] = 1;
                        if (PATH.length === 0 || PATH[PATH.length-1].x !== cx || PATH[PATH.length-1].y !== cy) {
                            PATH.push({x:cx, y:cy});
                        }
                    }
                    cy += cy < to.y ? 1 : -1;
                }
            }
            const last = waypoints[waypoints.length - 1];
            if (last.x < COLS && last.y < ROWS) {
                MAP[last.y][last.x] = 1;
                PATH.push({x:last.x, y:last.y});
            }
            if (PATH.length > 0) {
                MAP[PATH[0].y][PATH[0].x] = 2;
                const lp = PATH[PATH.length - 1];
                MAP[lp.y][lp.x] = 3;
            }
        }

        // Game state
        let gold, lives, wave, score, enemies, towers, projectiles, particles, damageNumbers;
        let selectedTower, selectedPlacedTower, waveInProgress, gameRunning, paused, gameSpeed;
        let hoverTile, enemiesSpawned, totalEnemiesThisWave;
        let lastFrameTime = 0;
        let gameTime = 0;
        let spawnQueue = [];
        let spawnTimer = 0;
        let mapIndex = -1;
        let upgradeTarget = null;

        function init() {
            document.getElementById('startWaveBtn').addEventListener('click', startWave);
            document.getElementById('newGameBtn').addEventListener('click', newGame);
            document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);
            document.getElementById('pauseBtn').addEventListener('click', togglePause);
            document.getElementById('speedBtn').addEventListener('click', toggleSpeed);

            document.querySelectorAll('.tower-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    selectedPlacedTower = null;
                    closeUpgradePanel();
                    if (btn.classList.contains('selected')) {
                        btn.classList.remove('selected');
                        selectedTower = null;
                    } else {
                        document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                        selectedTower = btn.dataset.tower;
                    }
                });
            });

            canvas.addEventListener('click', handleClick);
            canvas.addEventListener('contextmenu', handleRightClick);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseleave', () => {
                hoverTile = null;
                document.getElementById('infoPanel').style.display = 'none';
            });

            newGame();
            requestAnimationFrame(gameLoop);
        }

        function newGame() {
            mapIndex = (mapIndex + 1) % 3;
            generateMap();
            gold = 200;
            lives = 20;
            wave = 0;
            score = 0;
            enemies = [];
            towers = [];
            projectiles = [];
            particles = [];
            damageNumbers = [];
            selectedTower = null;
            selectedPlacedTower = null;
            upgradeTarget = null;
            waveInProgress = false;
            gameRunning = true;
            paused = false;
            gameSpeed = 1;
            hoverTile = null;
            enemiesSpawned = 0;
            totalEnemiesThisWave = 0;
            gameTime = 0;
            spawnQueue = [];
            spawnTimer = 0;
            document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
            document.getElementById('pauseBtn').textContent = 'Pause';
            document.getElementById('pauseBtn').classList.remove('active');
            document.getElementById('speedBtn').textContent = '1x';
            document.getElementById('speedBtn').classList.remove('active');
            closeUpgradePanel();
            updateDisplay();
            updateWavePreview();
            document.getElementById('message').textContent = 'Select a tower and click on grass to place it!';
        }

        function handleClick(e) {
            if (!gameRunning) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mx = (e.clientX - rect.left) * scaleX;
            const my = (e.clientY - rect.top) * scaleY;
            const x = Math.floor(mx / TILE);
            const y = Math.floor(my / TILE);

            if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return;

            // Check if clicking an existing tower (open upgrade panel)
            const existingTower = towers.find(t => t.x === x && t.y === y);
            if (existingTower) {
                openUpgradePanel(existingTower, e);
                return;
            }

            closeUpgradePanel();

            // Place new tower
            if (!selectedTower) {
                document.getElementById('message').textContent = 'Select a tower type first!';
                return;
            }

            if (MAP[y][x] !== 0) {
                document.getElementById('message').textContent = 'Cannot place tower on the path!';
                return;
            }

            const data = TOWER_DATA[selectedTower];
            if (gold < data.cost) {
                document.getElementById('message').textContent = 'Not enough gold!';
                return;
            }

            gold -= data.cost;
            const tower = {
                x, y,
                type: selectedTower,
                color: data.color,
                damage: data.damage,
                range: data.range,
                rate: data.rate,
                level: 0,
                totalCost: data.cost,
                lastFire: 0,
                powerLevel: 0,
                rangeLevel: 0,
                upgrades: []
            };
            // Copy special properties
            if (data.splash) tower.splash = data.splash;
            if (data.slow) { tower.slow = data.slow; tower.slowDuration = data.slowDuration; }
            if (data.burn) { tower.burn = data.burn; tower.burnDuration = data.burnDuration; }
            if (data.chain) tower.chain = data.chain;
            if (data.poisonAOE) { tower.poisonAOE = data.poisonAOE; tower.poisonDmg = data.poisonDmg; tower.poisonDuration = data.poisonDuration; }
            if (data.crit) { tower.crit = data.crit; tower.critMult = data.critMult; }
            if (data.hitsAll) tower.hitsAll = data.hitsAll;

            towers.push(tower);
            spawnParticles(x * TILE + TILE/2, y * TILE + TILE/2, data.color, 6);

            updateDisplay();
            document.getElementById('message').textContent = `Placed ${selectedTower} tower!`;
        }

        function openUpgradePanel(tower, e) {
            upgradeTarget = tower;
            const panel = document.getElementById('upgradePanel');
            const baseData = TOWER_DATA[tower.type];
            const paths = baseData.upgradePaths;

            let html = `<div class="title">${tower.type.charAt(0).toUpperCase() + tower.type.slice(1)} Tower (Lv ${tower.level + 1})</div>`;
            html += `<div style="color:#ccc;font-size:0.7rem;margin-bottom:6px;">Dmg: ${tower.damage} | Range: ${tower.range}px | Rate: ${tower.rate}ms</div>`;

            // Power path
            const pLvl = tower.powerLevel;
            html += `<div style="color:#ff6b6b;font-weight:bold;font-size:0.75rem;margin-top:4px;">&#x2694; Power Path (${pLvl}/3)</div>`;
            if (pLvl < paths.power.length) {
                const upg = paths.power[pLvl];
                const canAfford = gold >= upg.cost;
                html += `<div class="upgrade-option ${canAfford ? '' : 'locked'}" data-path="power" data-level="${pLvl}">`;
                html += `<div class="opt-name">${upg.label}</div>`;
                html += `<div class="opt-desc">${upg.desc}</div>`;
                html += `<div class="opt-cost">${upg.cost}g${canAfford ? '' : ' (need more gold)'}</div>`;
                html += `</div>`;
            } else {
                html += `<div style="color:#888;font-size:0.7rem;padding:4px;">MAX</div>`;
            }

            // Range path
            const rLvl = tower.rangeLevel;
            html += `<div style="color:#00ccff;font-weight:bold;font-size:0.75rem;margin-top:4px;">&#x1F3AF; Range/Utility Path (${rLvl}/3)</div>`;
            if (rLvl < paths.range.length) {
                const upg = paths.range[rLvl];
                const canAfford = gold >= upg.cost;
                html += `<div class="upgrade-option ${canAfford ? '' : 'locked'}" data-path="range" data-level="${rLvl}">`;
                html += `<div class="opt-name">${upg.label}</div>`;
                html += `<div class="opt-desc">${upg.desc}</div>`;
                html += `<div class="opt-cost">${upg.cost}g${canAfford ? '' : ' (need more gold)'}</div>`;
                html += `</div>`;
            } else {
                html += `<div style="color:#888;font-size:0.7rem;padding:4px;">MAX</div>`;
            }

            html += `<div style="color:#ff6b6b;font-size:0.7rem;margin-top:6px;">Sell: ${Math.floor(tower.totalCost * 0.6)}g (right-click)</div>`;
            html += `<button class="upgrade-close">Close</button>`;

            panel.innerHTML = html;
            panel.style.display = 'block';

            // Position panel
            const canvasRect = canvas.parentElement.getBoundingClientRect();
            let px = e.clientX - canvasRect.left + 15;
            let py = e.clientY - canvasRect.top - 10;
            if (px + 240 > canvasRect.width) px = px - 260;
            if (py + 250 > canvasRect.height) py = Math.max(5, canvasRect.height - 260);
            panel.style.left = px + 'px';
            panel.style.top = py + 'px';

            // Attach events
            panel.querySelectorAll('.upgrade-option:not(.locked)').forEach(opt => {
                opt.addEventListener('click', () => {
                    const path = opt.dataset.path;
                    const level = parseInt(opt.dataset.level);
                    applyUpgrade(tower, path, level);
                });
            });
            panel.querySelector('.upgrade-close').addEventListener('click', closeUpgradePanel);
        }

        function applyUpgrade(tower, path, level) {
            const baseData = TOWER_DATA[tower.type];
            const upg = baseData.upgradePaths[path][level];

            if (gold < upg.cost) return;

            gold -= upg.cost;
            tower.totalCost += upg.cost;
            tower.level++;
            if (path === 'power') tower.powerLevel++;
            else tower.rangeLevel++;

            tower.upgrades.push({ path, level, label: upg.label });

            // Apply upgrade stats
            if (upg.damage !== undefined) tower.damage = upg.damage;
            if (upg.range !== undefined) tower.range = upg.range;
            if (upg.rate !== undefined) tower.rate = upg.rate;
            if (upg.splash !== undefined) tower.splash = upg.splash;
            if (upg.slow !== undefined) tower.slow = upg.slow;
            if (upg.slowDuration !== undefined) tower.slowDuration = upg.slowDuration;
            if (upg.burn !== undefined) tower.burn = upg.burn;
            if (upg.burnDuration !== undefined) tower.burnDuration = upg.burnDuration;
            if (upg.chain !== undefined) tower.chain = upg.chain;
            if (upg.stun !== undefined) tower.stun = upg.stun;
            if (upg.detectStealth) tower.detectStealth = true;
            if (upg.crit !== undefined) tower.crit = upg.crit;
            if (upg.critMult !== undefined) tower.critMult = upg.critMult;
            if (upg.pierce) tower.pierce = true;
            if (upg.multishot) tower.multishot = upg.multishot;
            if (upg.armorPierce) tower.armorPierce = true;
            if (upg.armorShred !== undefined) tower.armorShred = upg.armorShred;
            if (upg.poisonAOE !== undefined) tower.poisonAOE = upg.poisonAOE;
            if (upg.poisonDmg !== undefined) tower.poisonDmg = upg.poisonDmg;
            if (upg.poisonDuration !== undefined) tower.poisonDuration = upg.poisonDuration;
            if (upg.burnSpread) tower.burnSpread = true;
            if (upg.freezeAOE !== undefined) tower.freezeAOE = upg.freezeAOE;
            if (upg.slowAOE !== undefined) tower.slowAOE = upg.slowAOE;
            if (upg.fireAOE !== undefined) tower.fireAOE = upg.fireAOE;
            if (upg.hitsAll !== undefined) tower.hitsAll = upg.hitsAll;
            if (upg.pull) tower.pull = true;
            if (upg.boostNearby !== undefined) tower.boostNearby = upg.boostNearby;

            spawnParticles(tower.x * TILE + TILE/2, tower.y * TILE + TILE/2, '#ffd700', 10);
            document.getElementById('message').textContent = `Upgraded: ${upg.label}!`;

            closeUpgradePanel();
            updateDisplay();
        }

        function closeUpgradePanel() {
            document.getElementById('upgradePanel').style.display = 'none';
            upgradeTarget = null;
        }

        function handleRightClick(e) {
            e.preventDefault();
            if (!gameRunning) return;
            closeUpgradePanel();

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mx = (e.clientX - rect.left) * scaleX;
            const my = (e.clientY - rect.top) * scaleY;
            const x = Math.floor(mx / TILE);
            const y = Math.floor(my / TILE);

            const towerIndex = towers.findIndex(t => t.x === x && t.y === y);
            if (towerIndex !== -1) {
                const tower = towers[towerIndex];
                const refund = Math.floor(tower.totalCost * 0.6);
                gold += refund;
                spawnParticles(tower.x * TILE + TILE/2, tower.y * TILE + TILE/2, '#ff6b6b', 6);
                towers.splice(towerIndex, 1);
                updateDisplay();
                document.getElementById('message').textContent = `Sold tower for ${refund}g!`;
            }
        }

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mx = (e.clientX - rect.left) * scaleX;
            const my = (e.clientY - rect.top) * scaleY;
            const x = Math.floor(mx / TILE);
            const y = Math.floor(my / TILE);

            if (x >= 0 && x < COLS && y >= 0 && y < ROWS) {
                hoverTile = {x, y};
            } else {
                hoverTile = null;
            }

            // Info panel for hovered towers (only when upgrade panel is closed)
            if (!upgradeTarget) {
                const tower = towers.find(t => t.x === x && t.y === y);
                const panel = document.getElementById('infoPanel');
                if (tower) {
                    let html = `<div class="title">${tower.type.charAt(0).toUpperCase() + tower.type.slice(1)} Tower (Lv ${tower.level + 1})</div>`;
                    html += `<div class="stat">Damage: <span>${tower.damage}</span></div>`;
                    html += `<div class="stat">Range: <span>${tower.range}px</span></div>`;
                    html += `<div class="stat">Fire Rate: <span>${tower.rate}ms</span></div>`;
                    if (tower.splash) html += `<div class="stat">Splash: <span>${tower.splash}px</span></div>`;
                    if (tower.slow) html += `<div class="stat">Slow: <span>${Math.round((1-tower.slow)*100)}%</span></div>`;
                    if (tower.burn) html += `<div class="stat">Burn: <span>${tower.burn} DPS</span></div>`;
                    if (tower.chain) html += `<div class="stat">Chains: <span>${tower.chain}</span></div>`;
                    if (tower.poisonDmg) html += `<div class="stat">Poison: <span>${tower.poisonDmg} DPS</span></div>`;
                    if (tower.crit) html += `<div class="stat">Crit: <span>${Math.round(tower.crit*100)}% (x${tower.critMult})</span></div>`;
                    if (tower.hitsAll) html += `<div class="stat">Hits: <span>All in range</span></div>`;
                    if (tower.detectStealth) html += `<div class="stat" style="color:#44ffcc">Detects stealth</div>`;
                    if (tower.stun) html += `<div class="stat">Stun: <span>${tower.stun}ms</span></div>`;
                    if (tower.armorShred) html += `<div class="stat">Armor shred: <span>${Math.round(tower.armorShred*100)}%</span></div>`;

                    if (tower.upgrades.length > 0) {
                        html += `<div class="upgrade-path">Upgrades: ${tower.upgrades.map(u => u.label).join(', ')}</div>`;
                    }
                    html += `<div class="upgrade">Click to upgrade</div>`;
                    html += `<div class="sell">Sell: ${Math.floor(tower.totalCost * 0.6)}g (right-click)</div>`;

                    panel.innerHTML = html;
                    panel.style.display = 'block';
                    const canvasRect = canvas.parentElement.getBoundingClientRect();
                    let px = e.clientX - canvasRect.left + 15;
                    let py = e.clientY - canvasRect.top - 10;
                    if (px + 170 > canvasRect.width) px = px - 185;
                    panel.style.left = px + 'px';
                    panel.style.top = py + 'px';
                } else {
                    panel.style.display = 'none';
                }
            }
        }

        function togglePause() {
            paused = !paused;
            const btn = document.getElementById('pauseBtn');
            btn.textContent = paused ? 'Resume' : 'Pause';
            btn.classList.toggle('active', paused);
        }

        function toggleSpeed() {
            const speeds = [1, 2, 3];
            const btn = document.getElementById('speedBtn');
            const idx = speeds.indexOf(gameSpeed);
            gameSpeed = speeds[(idx + 1) % speeds.length];
            btn.textContent = gameSpeed + 'x';
            btn.classList.toggle('active', gameSpeed > 1);
        }

        function getWaveComposition(w) {
            const result = [];
            const baseCount = 6 + w * 2;

            result.push({ type: 'normal', count: baseCount });

            if (w >= 3) result.push({ type: 'fast', count: Math.floor(w / 2) });
            if (w >= 5) result.push({ type: 'armored', count: Math.floor(w / 3) });
            if (w > 0 && w % 5 === 0) result.push({ type: 'boss', count: Math.max(1, Math.floor(w / 10)) });

            // New enemy types
            if (w >= 4) result.push({ type: 'swarm', count: Math.floor(w / 2) + 2 });
            if (w >= 6) result.push({ type: 'healer', count: Math.max(1, Math.floor(w / 5)) });
            if (w >= 8) result.push({ type: 'stealth', count: Math.max(1, Math.floor(w / 4)) });
            if (w >= 10) result.push({ type: 'shield', count: Math.max(1, Math.floor(w / 5)) });

            return result;
        }

        function startWave() {
            if (waveInProgress || !gameRunning) return;

            wave++;
            waveInProgress = true;

            const composition = getWaveComposition(wave);
            spawnQueue = [];

            for (const group of composition) {
                for (let i = 0; i < group.count; i++) {
                    spawnQueue.push(group.type);
                }
            }

            // Shuffle (keep bosses near end)
            for (let i = spawnQueue.length - 1; i > 0; i--) {
                if (spawnQueue[i] === 'boss') continue;
                const j = Math.floor(Math.random() * i);
                if (spawnQueue[j] === 'boss') continue;
                [spawnQueue[i], spawnQueue[j]] = [spawnQueue[j], spawnQueue[i]];
            }

            totalEnemiesThisWave = spawnQueue.length;
            enemiesSpawned = 0;
            spawnTimer = 0;

            updateDisplay();
            updateWavePreview();
        }

        function gameLoop(timestamp) {
            const dt = timestamp - lastFrameTime;
            lastFrameTime = timestamp;

            if (!paused) {
                for (let i = 0; i < gameSpeed; i++) {
                    update();
                }
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        function canTowerSee(tower, enemy) {
            if (enemy.stealthed && !tower.detectStealth) return false;
            return true;
        }

        function update() {
            if (!gameRunning) return;

            const TICK = 16;
            gameTime += TICK;

            // Spawn enemies
            if (spawnQueue.length > 0) {
                spawnTimer += TICK;
                const nextType = spawnQueue[0];
                const spawnDelay = nextType === 'boss' ? 800 : nextType === 'swarm' ? 200 : 450;
                if (spawnTimer >= spawnDelay) {
                    spawnTimer -= spawnDelay;
                    const type = spawnQueue.shift();
                    const eData = ENEMY_TYPES[type];
                    const baseHealth = 30 + wave * 12;
                    const baseSpeed = 1.0 + wave * 0.03;
                    const health = Math.round(baseHealth * eData.healthMult);
                    const enemy = {
                        pathIndex: 0,
                        x: PATH[0].x * TILE + TILE / 2,
                        y: PATH[0].y * TILE + TILE / 2,
                        health, maxHealth: health,
                        speed: baseSpeed * eData.speedMult,
                        color: eData.color,
                        radius: eData.radius,
                        type: type,
                        reward: Math.round((5 + wave) * eData.reward),
                        slowTimer: 0, slowAmount: 1,
                        burnTimer: 0, burnDamage: 0, lastBurnTick: 0,
                        poisonTimer: 0, poisonDamage: 0, lastPoisonTick: 0,
                        stunTimer: 0,
                        stealthed: eData.stealthy || false,
                        heals: eData.heals || false,
                        lastHealTick: 0,
                        shield: eData.hasShield ? Math.round(health * 0.5) : 0,
                        maxShield: eData.hasShield ? Math.round(health * 0.5) : 0,
                        armorMult: 1.0
                    };
                    enemies.push(enemy);
                    enemiesSpawned++;
                }
            }

            // Update enemies
            enemies = enemies.filter(enemy => {
                if (enemy.dead) return false;

                // Stun check
                if (enemy.stunTimer > gameTime) return true;

                // Burn DOT
                if (enemy.burnTimer > gameTime && gameTime - enemy.lastBurnTick >= 500) {
                    dealDamageToEnemy(enemy, enemy.burnDamage, '#ff4500');
                    enemy.lastBurnTick = gameTime;
                    spawnParticles(enemy.x, enemy.y, '#ff4500', 2);
                    if (enemy.health <= 0) { onEnemyKilled(enemy); return false; }
                }

                // Poison DOT
                if (enemy.poisonTimer > gameTime && gameTime - enemy.lastPoisonTick >= 500) {
                    dealDamageToEnemy(enemy, enemy.poisonDamage, '#00cc44');
                    enemy.lastPoisonTick = gameTime;
                    spawnParticles(enemy.x, enemy.y, '#00cc44', 2);
                    if (enemy.health <= 0) { onEnemyKilled(enemy); return false; }
                }

                // Healer: heal nearby enemies
                if (enemy.heals && gameTime - enemy.lastHealTick >= 1000) {
                    enemy.lastHealTick = gameTime;
                    for (const other of enemies) {
                        if (other === enemy || other.dead) continue;
                        const dx = other.x - enemy.x;
                        const dy = other.y - enemy.y;
                        if (Math.sqrt(dx*dx + dy*dy) < 80) {
                            other.health = Math.min(other.maxHealth, other.health + Math.round(other.maxHealth * 0.03));
                            spawnParticles(other.x, other.y, '#44ffcc', 2);
                        }
                    }
                }

                // Movement
                let speed = enemy.speed;
                if (enemy.slowTimer > gameTime) speed *= enemy.slowAmount;

                const target = PATH[enemy.pathIndex];
                if (!target) {
                    lives--;
                    updateDisplay();
                    spawnParticles(enemy.x, enemy.y, '#ff0000', 10);
                    if (lives <= 0) gameOver();
                    return false;
                }

                const tx = target.x * TILE + TILE / 2;
                const ty = target.y * TILE + TILE / 2;
                const dx = tx - enemy.x;
                const dy = ty - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < speed * 2) {
                    enemy.pathIndex++;
                } else {
                    enemy.x += (dx / dist) * speed * 2;
                    enemy.y += (dy / dist) * speed * 2;
                }

                return true;
            });

            // Towers fire
            towers.forEach(tower => {
                if (gameTime - tower.lastFire < tower.rate) return;

                const tcx = tower.x * TILE + TILE / 2;
                const tcy = tower.y * TILE + TILE / 2;

                // Boost nearby towers
                if (tower.boostNearby) {
                    towers.forEach(other => {
                        if (other === tower) return;
                        const dx = (other.x - tower.x) * TILE;
                        const dy = (other.y - tower.y) * TILE;
                        if (Math.sqrt(dx*dx + dy*dy) < 120) {
                            other.boosted = gameTime + 1000;
                            other.boostAmount = tower.boostNearby;
                        }
                    });
                }

                // Tesla: hits all enemies in range
                if (tower.hitsAll) {
                    let hit = false;
                    for (const enemy of enemies) {
                        if (enemy.dead || !canTowerSee(tower, enemy)) continue;
                        const dx = enemy.x - tcx;
                        const dy = enemy.y - tcy;
                        if (Math.sqrt(dx*dx + dy*dy) < tower.range) {
                            hit = true;
                            let dmg = tower.damage;
                            if (tower.boosted > gameTime) dmg = Math.round(dmg * (1 + tower.boostAmount));
                            dealDamageToEnemy(enemy, dmg, tower.color);
                            spawnDamageNumber(enemy.x, enemy.y, dmg, tower.color);
                            if (tower.stun) enemy.stunTimer = Math.max(enemy.stunTimer, gameTime + tower.stun);
                            // Pull effect
                            if (tower.pull) {
                                const pdx = tcx - enemy.x;
                                const pdy = tcy - enemy.y;
                                const pd = Math.sqrt(pdx*pdx + pdy*pdy);
                                if (pd > 5) {
                                    enemy.x += (pdx / pd) * 5;
                                    enemy.y += (pdy / pd) * 5;
                                }
                            }
                            drawLightningBolt(tcx, tcy, enemy.x, enemy.y);
                            if (enemy.health <= 0 && !enemy.dead) {
                                enemy.dead = true;
                                onEnemyKilled(enemy);
                            }
                        }
                    }
                    if (hit) tower.lastFire = gameTime;
                    return;
                }

                // Find target
                let target = null;
                let minDist = tower.range;
                for (const enemy of enemies) {
                    if (enemy.dead || !canTowerSee(tower, enemy)) continue;
                    const dx = enemy.x - tcx;
                    const dy = enemy.y - tcy;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < minDist) {
                        minDist = dist;
                        target = enemy;
                    }
                }

                if (target) {
                    tower.lastFire = gameTime;

                    if (tower.chain) {
                        handleChainLightning(tower, target, tcx, tcy);
                    } else if (tower.poisonAOE) {
                        handlePoisonAttack(tower, target, tcx, tcy);
                    } else {
                        const shotCount = tower.multishot || 1;
                        const targets = [target];
                        if (shotCount > 1) {
                            // Find additional targets
                            const sorted = enemies.filter(e => !e.dead && e !== target && canTowerSee(tower, e))
                                .map(e => ({ e, d: Math.sqrt((e.x-tcx)**2 + (e.y-tcy)**2) }))
                                .filter(o => o.d < tower.range)
                                .sort((a,b) => a.d - b.d);
                            for (let i = 0; i < shotCount - 1 && i < sorted.length; i++) {
                                targets.push(sorted[i].e);
                            }
                        }

                        for (const t of targets) {
                            let dmg = tower.damage;
                            if (tower.boosted > gameTime) dmg = Math.round(dmg * (1 + tower.boostAmount));
                            let isCrit = false;
                            if (tower.crit && Math.random() < tower.crit) {
                                dmg = Math.round(dmg * tower.critMult);
                                isCrit = true;
                            }

                            projectiles.push({
                                x: tcx, y: tcy, target: t,
                                damage: dmg,
                                slow: tower.slow || 0,
                                slowDuration: tower.slowDuration || 0,
                                burn: tower.burn || 0,
                                burnDuration: tower.burnDuration || 0,
                                splash: tower.splash || 0,
                                stun: tower.stun || 0,
                                color: tower.color,
                                type: tower.type,
                                armorPierce: tower.armorPierce || false,
                                armorShred: tower.armorShred || 0,
                                burnSpread: tower.burnSpread || false,
                                slowAOE: tower.slowAOE || 0,
                                fireAOE: tower.fireAOE || 0,
                                freezeAOE: tower.freezeAOE || 0,
                                isCrit
                            });
                        }
                    }
                }
            });

            // Update projectiles
            projectiles = projectiles.filter(proj => {
                if (!enemies.includes(proj.target) || proj.target.dead) return false;

                const dx = proj.target.x - proj.x;
                const dy = proj.target.y - proj.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 10) {
                    applyProjectileDamage(proj, proj.target);
                    return false;
                }

                const speed = proj.type === 'cannon' ? 6 : proj.type === 'sniper' ? 14 : 10;
                proj.x += (dx / dist) * speed;
                proj.y += (dy / dist) * speed;
                return true;
            });

            // Update particles
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.03;
                p.vy += 0.05;
                return p.life > 0;
            });

            // Damage numbers
            damageNumbers = damageNumbers.filter(d => {
                d.y -= 0.8;
                d.life -= 0.02;
                return d.life > 0;
            });

            // Remove dead enemies
            enemies = enemies.filter(e => !e.dead);

            // Wave end check
            if (waveInProgress && enemies.length === 0 && spawnQueue.length === 0 && enemiesSpawned >= totalEnemiesThisWave) {
                waveInProgress = false;
                const bonus = wave * 15;
                gold += bonus;
                score += wave * 50;
                document.getElementById('message').textContent = `Wave ${wave} complete! Bonus: +${bonus}g`;
                updateDisplay();
                updateWavePreview();
            }
        }

        function dealDamageToEnemy(enemy, damage, color) {
            // Armor shred reduces damage taken multiplier
            let dmg = Math.round(damage * enemy.armorMult);

            // Shield absorbs damage first
            if (enemy.shield > 0) {
                if (dmg <= enemy.shield) {
                    enemy.shield -= dmg;
                    spawnDamageNumber(enemy.x, enemy.y, dmg, '#ff8844');
                    return;
                } else {
                    dmg -= enemy.shield;
                    enemy.shield = 0;
                }
            }

            enemy.health -= dmg;
        }

        function applyProjectileDamage(proj, target) {
            let dmg = proj.damage;
            if (proj.armorPierce) {
                // Ignore armor multiplier
            } else {
                dmg = Math.round(dmg * target.armorMult);
            }

            // Armor shred debuff
            if (proj.armorShred > 0) {
                target.armorMult = Math.max(0.5, target.armorMult - proj.armorShred);
            }

            // Shield absorb
            if (target.shield > 0) {
                if (dmg <= target.shield) {
                    target.shield -= dmg;
                    spawnDamageNumber(target.x, target.y, dmg, '#ff8844');
                    dmg = 0;
                } else {
                    dmg -= target.shield;
                    target.shield = 0;
                }
            }

            if (dmg > 0) {
                target.health -= dmg;
                const color = proj.isCrit ? '#ffff00' : proj.color;
                const text = proj.isCrit ? dmg + '!' : '' + dmg;
                spawnDamageNumber(target.x, target.y, text, color);
            }

            // Splash
            if (proj.splash > 0) {
                spawnParticles(target.x, target.y, '#ff8800', 8);
                for (const enemy of enemies) {
                    if (enemy === target || enemy.dead) continue;
                    const dx = enemy.x - target.x;
                    const dy = enemy.y - target.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < proj.splash) {
                        const splashDmg = Math.round(proj.damage * (1 - dist / proj.splash) * 0.6);
                        if (splashDmg > 0) {
                            dealDamageToEnemy(enemy, splashDmg, '#ff8800');
                            spawnDamageNumber(enemy.x, enemy.y, splashDmg, '#ff8800');
                            if (proj.stun) enemy.stunTimer = Math.max(enemy.stunTimer, gameTime + proj.stun);
                            if (enemy.health <= 0 && !enemy.dead) { enemy.dead = true; onEnemyKilled(enemy); }
                        }
                    }
                }
            }

            // Slow
            if (proj.slow > 0) {
                target.slowTimer = gameTime + proj.slowDuration;
                target.slowAmount = proj.slow;
                spawnParticles(target.x, target.y, '#00bfff', 3);
            }

            // Slow AOE (ice blizzard)
            if (proj.slowAOE > 0) {
                for (const enemy of enemies) {
                    if (enemy.dead) continue;
                    const dx = enemy.x - target.x;
                    const dy = enemy.y - target.y;
                    if (Math.sqrt(dx*dx + dy*dy) < proj.slowAOE) {
                        enemy.slowTimer = gameTime + (proj.slowDuration || 1500);
                        enemy.slowAmount = proj.slow || 0.5;
                    }
                }
            }

            // Freeze AOE
            if (proj.freezeAOE > 0) {
                for (const enemy of enemies) {
                    if (enemy.dead) continue;
                    const dx = enemy.x - target.x;
                    const dy = enemy.y - target.y;
                    if (Math.sqrt(dx*dx + dy*dy) < proj.freezeAOE) {
                        enemy.stunTimer = Math.max(enemy.stunTimer, gameTime + 1000);
                        spawnParticles(enemy.x, enemy.y, '#00bfff', 3);
                    }
                }
            }

            // Burn
            if (proj.burn > 0) {
                target.burnTimer = gameTime + proj.burnDuration;
                target.burnDamage = proj.burn;
                target.lastBurnTick = gameTime;

                // Burn spread
                if (proj.burnSpread) {
                    for (const enemy of enemies) {
                        if (enemy === target || enemy.dead) continue;
                        const dx = enemy.x - target.x;
                        const dy = enemy.y - target.y;
                        if (Math.sqrt(dx*dx + dy*dy) < 60) {
                            enemy.burnTimer = gameTime + proj.burnDuration * 0.5;
                            enemy.burnDamage = Math.round(proj.burn * 0.5);
                            enemy.lastBurnTick = gameTime;
                        }
                    }
                }
            }

            // Fire AOE
            if (proj.fireAOE > 0) {
                spawnParticles(target.x, target.y, '#ff4500', 10);
                for (const enemy of enemies) {
                    if (enemy === target || enemy.dead) continue;
                    const dx = enemy.x - target.x;
                    const dy = enemy.y - target.y;
                    if (Math.sqrt(dx*dx + dy*dy) < proj.fireAOE) {
                        const fireDmg = Math.round(proj.damage * 0.4);
                        dealDamageToEnemy(enemy, fireDmg, '#ff4500');
                        spawnDamageNumber(enemy.x, enemy.y, fireDmg, '#ff4500');
                        enemy.burnTimer = gameTime + proj.burnDuration;
                        enemy.burnDamage = proj.burn;
                        enemy.lastBurnTick = gameTime;
                        if (enemy.health <= 0 && !enemy.dead) { enemy.dead = true; onEnemyKilled(enemy); }
                    }
                }
            }

            // Stun
            if (proj.stun > 0) {
                target.stunTimer = Math.max(target.stunTimer, gameTime + proj.stun);
            }

            // Reveal stealth
            if (target.stealthed) {
                target.revealTimer = gameTime + 2000;
            }

            // Kill check
            if (target.health <= 0 && !target.dead) {
                target.dead = true;
                onEnemyKilled(target);
            }
        }

        function handlePoisonAttack(tower, target, tcx, tcy) {
            // Poison hits all enemies in AOE around target
            spawnParticles(target.x, target.y, '#00cc44', 6);
            let dmg = tower.damage;
            if (tower.boosted > gameTime) dmg = Math.round(dmg * (1 + tower.boostAmount));

            for (const enemy of enemies) {
                if (enemy.dead) continue;
                const dx = enemy.x - target.x;
                const dy = enemy.y - target.y;
                if (Math.sqrt(dx*dx + dy*dy) < tower.poisonAOE) {
                    dealDamageToEnemy(enemy, dmg, '#00cc44');
                    spawnDamageNumber(enemy.x, enemy.y, dmg, '#00cc44');
                    enemy.poisonTimer = gameTime + tower.poisonDuration;
                    enemy.poisonDamage = tower.poisonDmg;
                    enemy.lastPoisonTick = gameTime;
                    if (tower.armorShred) {
                        enemy.armorMult = Math.max(0.5, enemy.armorMult - tower.armorShred);
                    }
                    if (tower.slow) {
                        enemy.slowTimer = gameTime + tower.slowDuration;
                        enemy.slowAmount = tower.slow;
                    }
                    if (enemy.health <= 0 && !enemy.dead) { enemy.dead = true; onEnemyKilled(enemy); }
                }
            }

            // Visual: poison cloud effect
            projectiles.push({
                x: target.x, y: target.y, target: target,
                damage: 0, color: '#00cc44', type: 'poison_visual',
                splash: 0, slow: 0, slowDuration: 0, burn: 0, burnDuration: 0,
                stun: 0, armorPierce: false, armorShred: 0, burnSpread: false,
                slowAOE: 0, fireAOE: 0, freezeAOE: 0, isCrit: false,
                life: 0.5, isVisual: true
            });
        }

        function handleChainLightning(tower, firstTarget, tcx, tcy) {
            const chainCount = tower.chain;
            const chainRange = 80;
            const hit = [firstTarget];
            let prevX = tcx, prevY = tcy;

            drawLightningBolt(prevX, prevY, firstTarget.x, firstTarget.y);
            let dmg = tower.damage;
            if (tower.boosted > gameTime) dmg = Math.round(dmg * (1 + tower.boostAmount));
            dealDamageToEnemy(firstTarget, dmg, '#ffff00');
            spawnDamageNumber(firstTarget.x, firstTarget.y, dmg, '#ffff00');
            if (tower.stun) firstTarget.stunTimer = Math.max(firstTarget.stunTimer, gameTime + tower.stun);
            if (firstTarget.health <= 0 && !firstTarget.dead) {
                firstTarget.dead = true;
                onEnemyKilled(firstTarget);
            }

            prevX = firstTarget.x;
            prevY = firstTarget.y;

            for (let c = 1; c < chainCount; c++) {
                let nearest = null;
                let nearDist = chainRange;
                for (const enemy of enemies) {
                    if (hit.includes(enemy) || enemy.dead) continue;
                    if (!canTowerSee(tower, enemy)) continue;
                    const dx = enemy.x - prevX;
                    const dy = enemy.y - prevY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < nearDist) {
                        nearDist = dist;
                        nearest = enemy;
                    }
                }
                if (!nearest) break;

                hit.push(nearest);
                drawLightningBolt(prevX, prevY, nearest.x, nearest.y);
                const chainDmg = Math.round(dmg * 0.7);
                dealDamageToEnemy(nearest, chainDmg, '#ffff00');
                spawnDamageNumber(nearest.x, nearest.y, chainDmg, '#ffff00');
                if (tower.stun) nearest.stunTimer = Math.max(nearest.stunTimer, gameTime + tower.stun);
                if (nearest.health <= 0 && !nearest.dead) {
                    nearest.dead = true;
                    onEnemyKilled(nearest);
                }
                prevX = nearest.x;
                prevY = nearest.y;
            }
        }

        let lightningBolts = [];
        function drawLightningBolt(x1, y1, x2, y2) {
            lightningBolts.push({ x1, y1, x2, y2, life: 1.0 });
        }

        function onEnemyKilled(enemy) {
            gold += enemy.reward;
            score += enemy.reward * 10;
            spawnParticles(enemy.x, enemy.y, enemy.color, 8);
            updateDisplay();
        }

        function spawnParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 1,
                    color,
                    life: 1.0
                });
            }
        }

        function spawnDamageNumber(x, y, damage, color) {
            damageNumbers.push({
                x: x + (Math.random() - 0.5) * 10,
                y: y - 15,
                text: typeof damage === 'string' ? '-' + damage : '-' + damage,
                color,
                life: 1.0
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw map
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const cell = MAP[y][x];
                    if (cell === 0) {
                        ctx.fillStyle = ((x + y) % 2 === 0) ? '#3a5f0b' : '#3e6410';
                    } else if (cell === 1) {
                        ctx.fillStyle = '#8b7355';
                    } else if (cell === 2) {
                        ctx.fillStyle = '#4a9b4a';
                    } else {
                        ctx.fillStyle = '#ff6b6b';
                    }
                    ctx.fillRect(x * TILE, y * TILE, TILE, TILE);
                    ctx.strokeStyle = 'rgba(0,0,0,0.15)';
                    ctx.strokeRect(x * TILE, y * TILE, TILE, TILE);
                }
            }

            // Path arrows
            ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
            for (let i = 0; i < PATH.length - 1; i += 3) {
                const p = PATH[i];
                const n = PATH[Math.min(i + 1, PATH.length - 1)];
                const cx = p.x * TILE + TILE / 2;
                const cy = p.y * TILE + TILE / 2;
                const angle = Math.atan2(n.y - p.y, n.x - p.x);
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(8, 0);
                ctx.lineTo(-4, -5);
                ctx.lineTo(-4, 5);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            // Hover preview
            if (hoverTile && selectedTower && gameRunning) {
                const hx = hoverTile.x, hy = hoverTile.y;
                if (hx >= 0 && hx < COLS && hy >= 0 && hy < ROWS && MAP[hy][hx] === 0 && !towers.some(t => t.x === hx && t.y === hy)) {
                    const data = TOWER_DATA[selectedTower];
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.arc(hx * TILE + TILE/2, hy * TILE + TILE/2, data.range, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = data.color;
                    ctx.beginPath();
                    ctx.arc(hx * TILE + TILE/2, hy * TILE + TILE/2, TILE / 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }
            }

            // Draw towers
            towers.forEach(tower => {
                const cx = tower.x * TILE + TILE / 2;
                const cy = tower.y * TILE + TILE / 2;

                // Base
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(tower.x * TILE + 4, tower.y * TILE + 4, TILE - 8, TILE - 8);

                // Boosted glow
                if (tower.boosted > gameTime) {
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(cx, cy, TILE / 2 + 3, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.lineWidth = 1;
                }

                // Tower body
                const radius = TILE / 3 + tower.level * 1.5;
                ctx.fillStyle = tower.color;
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.lineWidth = 1;

                // Upgrade path indicators (power = red dots left, range = blue dots right)
                if (tower.powerLevel > 0) {
                    for (let i = 0; i < tower.powerLevel; i++) {
                        ctx.fillStyle = '#ff6b6b';
                        ctx.beginPath();
                        ctx.arc(cx - 6 - i * 5, cy + radius + 5, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                if (tower.rangeLevel > 0) {
                    for (let i = 0; i < tower.rangeLevel; i++) {
                        ctx.fillStyle = '#00ccff';
                        ctx.beginPath();
                        ctx.arc(cx + 6 + i * 5, cy + radius + 5, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Range circle on hover
                if (hoverTile && hoverTile.x === tower.x && hoverTile.y === tower.y) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.arc(cx, cy, tower.range, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Detect stealth indicator
                if (tower.detectStealth) {
                    ctx.fillStyle = '#44ffcc';
                    ctx.font = 'bold 8px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('EYE', cx, cy - radius - 3);
                    ctx.textAlign = 'left';
                }
            });

            // Draw enemies
            enemies.forEach(enemy => {
                // Stealth: mostly invisible unless revealed
                if (enemy.stealthed && (!enemy.revealTimer || enemy.revealTimer < gameTime)) {
                    ctx.globalAlpha = 0.15;
                } else if (enemy.stealthed) {
                    ctx.globalAlpha = 0.6;
                }

                // Stun visual
                if (enemy.stunTimer > gameTime) {
                    ctx.strokeStyle = 'rgba(255, 255, 100, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.radius + 5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.lineWidth = 1;
                }

                // Slow visual
                if (enemy.slowTimer > gameTime) {
                    ctx.strokeStyle = 'rgba(0, 191, 255, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.radius + 4, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.lineWidth = 1;
                }

                // Burn visual
                if (enemy.burnTimer > gameTime) {
                    ctx.strokeStyle = 'rgba(255, 69, 0, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.radius + 2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.lineWidth = 1;
                }

                // Poison visual
                if (enemy.poisonTimer > gameTime) {
                    ctx.strokeStyle = 'rgba(0, 204, 68, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.radius + 3, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.lineWidth = 1;
                }

                // Enemy body
                ctx.fillStyle = enemy.color;
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                ctx.stroke();

                // Armored ring
                if (enemy.type === 'armored') {
                    ctx.strokeStyle = 'rgba(200,200,255,0.6)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.radius - 3, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.lineWidth = 1;
                }

                // Boss crown
                if (enemy.type === 'boss') {
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.moveTo(enemy.x - 6, enemy.y - enemy.radius - 2);
                    ctx.lineTo(enemy.x - 4, enemy.y - enemy.radius - 8);
                    ctx.lineTo(enemy.x, enemy.y - enemy.radius - 4);
                    ctx.lineTo(enemy.x + 4, enemy.y - enemy.radius - 8);
                    ctx.lineTo(enemy.x + 6, enemy.y - enemy.radius - 2);
                    ctx.closePath();
                    ctx.fill();
                }

                // Healer cross
                if (enemy.heals) {
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(enemy.x - 4, enemy.y - 1, 8, 2);
                    ctx.fillRect(enemy.x - 1, enemy.y - 4, 2, 8);
                }

                // Shield bar
                if (enemy.maxShield > 0) {
                    const barWidth = enemy.radius * 2 + 4;
                    const shieldPct = enemy.shield / enemy.maxShield;
                    const barY = enemy.y - enemy.radius - (enemy.type === 'boss' ? 18 : 10);
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(enemy.x - barWidth/2, barY, barWidth, 3);
                    ctx.fillStyle = '#ff8844';
                    ctx.fillRect(enemy.x - barWidth/2, barY, barWidth * shieldPct, 3);
                }

                // Health bar
                const barWidth = enemy.radius * 2 + 4;
                const healthPct = enemy.health / enemy.maxHealth;
                const barY = enemy.y - enemy.radius - (enemy.type === 'boss' ? 14 : 6);
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(enemy.x - barWidth/2, barY, barWidth, 4);
                let hpColor = healthPct > 0.6 ? '#00ff00' : healthPct > 0.3 ? '#ffff00' : '#ff4444';
                ctx.fillStyle = hpColor;
                ctx.fillRect(enemy.x - barWidth/2, barY, barWidth * healthPct, 4);

                ctx.globalAlpha = 1.0;
            });

            // Draw projectiles
            projectiles.forEach(proj => {
                if (proj.isVisual) {
                    // Poison cloud visual
                    ctx.globalAlpha = proj.life || 0.3;
                    ctx.fillStyle = 'rgba(0, 204, 68, 0.3)';
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, 30, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    proj.life -= 0.05;
                    return;
                }

                ctx.fillStyle = proj.color || '#fff';
                ctx.beginPath();
                if (proj.type === 'cannon') {
                    ctx.arc(proj.x, proj.y, 5, 0, Math.PI * 2);
                } else if (proj.type === 'fire') {
                    ctx.arc(proj.x, proj.y, 4, 0, Math.PI * 2);
                } else if (proj.type === 'sniper') {
                    // Sniper trail
                    ctx.fillStyle = proj.isCrit ? '#ffff00' : '#aa4400';
                    ctx.arc(proj.x, proj.y, 3, 0, Math.PI * 2);
                } else {
                    ctx.arc(proj.x, proj.y, 3, 0, Math.PI * 2);
                }
                ctx.fill();
            });

            // Filter out done visual projectiles
            projectiles = projectiles.filter(p => !p.isVisual || (p.life && p.life > 0));

            // Lightning bolts
            lightningBolts = lightningBolts.filter(bolt => {
                ctx.strokeStyle = `rgba(255, 255, 100, ${bolt.life})`;
                ctx.lineWidth = 2 * bolt.life;
                ctx.beginPath();
                const dx = bolt.x2 - bolt.x1;
                const dy = bolt.y2 - bolt.y1;
                const segments = 6;
                ctx.moveTo(bolt.x1, bolt.y1);
                for (let s = 1; s < segments; s++) {
                    const t = s / segments;
                    const jitter = (1 - t) * 8;
                    ctx.lineTo(
                        bolt.x1 + dx * t + (Math.random() - 0.5) * jitter,
                        bolt.y1 + dy * t + (Math.random() - 0.5) * jitter
                    );
                }
                ctx.lineTo(bolt.x2, bolt.y2);
                ctx.stroke();
                ctx.lineWidth = 1;
                bolt.life -= 0.08;
                return bolt.life > 0;
            });

            // Particles
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 2 * p.life, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            // Damage numbers
            damageNumbers.forEach(d => {
                ctx.globalAlpha = d.life;
                ctx.fillStyle = d.color;
                ctx.font = 'bold 12px monospace';
                ctx.fillText(d.text, d.x, d.y);
            });
            ctx.globalAlpha = 1.0;

            // Start/End labels
            if (PATH.length > 0) {
                ctx.font = 'bold 11px monospace';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText('START', PATH[0].x * TILE + TILE/2, PATH[0].y * TILE + TILE/2 + 4);
                const lp = PATH[PATH.length - 1];
                ctx.fillText('END', lp.x * TILE + TILE/2, lp.y * TILE + TILE/2 + 4);
                ctx.textAlign = 'left';
            }

            // Paused overlay
            if (paused) {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 36px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
                ctx.textAlign = 'left';
            }

            // Game over
            if (!gameRunning) {
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ff4444';
                ctx.font = 'bold 40px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 20);
                ctx.fillStyle = '#fff';
                ctx.font = '20px sans-serif';
                ctx.fillText(`Wave: ${wave}  |  Score: ${score}`, canvas.width/2, canvas.height/2 + 20);
                ctx.fillText('Click "New Game" to try again', canvas.width/2, canvas.height/2 + 50);
                ctx.textAlign = 'left';
            }
        }

        function gameOver() {
            gameRunning = false;
            document.getElementById('message').textContent = `Game Over! Reached wave ${wave} with score ${score}`;
        }

        function updateDisplay() {
            document.getElementById('gold').textContent = gold;
            document.getElementById('lives').textContent = lives;
            document.getElementById('wave').textContent = wave;
            document.getElementById('score').textContent = score;

            document.querySelectorAll('.tower-btn').forEach(btn => {
                const data = TOWER_DATA[btn.dataset.tower];
                btn.disabled = gold < data.cost;
            });
        }

        function updateWavePreview() {
            const nextWave = wave + 1;
            const comp = getWaveComposition(nextWave);
            let preview = `Next wave (${nextWave}): `;
            const parts = comp.map(c => `<span>${c.count} ${c.type}</span>`);
            preview += parts.join(', ');
            document.getElementById('wavePreview').innerHTML = preview;
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        init();
    </script>
    <script src="../js/game-utils.js"></script>
    <script src="../js/accounts.js"></script>
</body>
</html>
