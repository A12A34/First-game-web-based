<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8 Ball Pool - Game Hub</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../css/styles.css">
    <style>
        .fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            font-size: 1.2rem;
            z-index: 100;
        }
        
        .ball-type-indicator {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            margin-top: 5px;
        }
        .ball-type-indicator.solid {
            background: linear-gradient(90deg, #ff6b6b, #ffa500);
            color: #fff;
        }
        .ball-type-indicator.stripe {
            background: linear-gradient(90deg, #fff 0%, #4ecdc4 20%, #4ecdc4 80%, #fff 100%);
            color: #333;
        }
        
        .shot-info {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 10px 0;
            font-size: 0.9rem;
            color: #a0a0a0;
        }
        
        .spin-control {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
            margin: 10px 0;
        }
        
        .spin-pad {
            width: 80px;
            height: 80px;
            background: radial-gradient(circle, #fff 0%, #ccc 100%);
            border-radius: 50%;
            position: relative;
            cursor: pointer;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.3);
        }
        
        .spin-dot {
            width: 16px;
            height: 16px;
            background: #ff0000;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        
        .spin-label {
            font-size: 0.8rem;
            color: #a0a0a0;
        }
        
        .pool-table {
            position: relative;
            width: 1000px;
            height: 500px;
            background: #0d6b38;
            border: 25px solid #5d3a1a;
            border-radius: 10px;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.3), 0 10px 30px rgba(0,0,0,0.5);
            margin: 20px auto;
            overflow: hidden;
        }
        .pool-table::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 50px,
                rgba(0,0,0,0.02) 50px,
                rgba(0,0,0,0.02) 100px
            );
        }
        .pocket {
            position: absolute;
            width: 35px;
            height: 35px;
            background: #000;
            border-radius: 50%;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.8);
        }
        .pocket.tl { top: -10px; left: -10px; }
        .pocket.tr { top: -10px; right: -10px; }
        .pocket.bl { bottom: -10px; left: -10px; }
        .pocket.br { bottom: -10px; right: -10px; }
        .pocket.ml { top: 50%; left: -15px; transform: translateY(-50%); }
        .pocket.mr { top: 50%; right: -15px; transform: translateY(-50%); }
        
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }
        
        .power-bar {
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px auto;
        }
        .power-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #ffff00, #ff4444);
            transition: width 0.05s;
        }
        
        .player-info {
            display: flex;
            justify-content: center;
            gap: 50px;
            margin: 15px 0;
        }
        .player {
            padding: 15px 30px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            text-align: center;
            transition: all 0.3s;
        }
        .player.active {
            background: rgba(0, 217, 255, 0.2);
            border: 2px solid #00d9ff;
            transform: scale(1.05);
        }
        .player-balls {
            display: flex;
            gap: 5px;
            margin-top: 10px;
            justify-content: center;
        }
        .mini-ball {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        .mini-ball.solid { background: #ff6b6b; }
        .mini-ball.stripe { 
            background: linear-gradient(90deg, #fff 30%, #4ecdc4 30%, #4ecdc4 70%, #fff 70%);
        }
        
        .game-message {
            text-align: center;
            font-size: 1.2rem;
            min-height: 30px;
            color: #00d9ff;
        }
        
        .difficulty-selection {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 15px 0;
        }
        .diff-btn {
            padding: 8px 20px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 15px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
        }
        .diff-btn.active {
            background: linear-gradient(45deg, #00d9ff, #00ff88);
            color: #1a1a2e;
        }
    </style>
</head>
<body>
    <button class="fullscreen-btn" id="fullscreenBtn">‚õ∂</button>
    
    <div class="container">
        <a href="../index.html" class="back-btn">‚Üê Back to Games</a>
        
        <div class="game-container">
            <h1 class="game-title">üé± 8 Ball Pool</h1>
            
            <div class="mode-selection">
                <button class="mode-btn active" data-mode="2player">2 Players</button>
                <button class="mode-btn" data-mode="ai">vs AI</button>
            </div>
            
            <div id="difficultyContainer" class="difficulty-selection hidden">
                <button class="diff-btn" data-difficulty="easy">Easy</button>
                <button class="diff-btn active" data-difficulty="medium">Medium</button>
                <button class="diff-btn" data-difficulty="hard">Hard</button>
            </div>
            
            <div class="player-info">
                <div class="player active" id="player1">
                    <div>Player 1</div>
                    <span class="ball-type-indicator" id="p1Type" style="display:none;"></span>
                    <div class="player-balls" id="p1Balls"></div>
                </div>
                <div class="player" id="player2">
                    <div id="p2Name">Player 2</div>
                    <span class="ball-type-indicator" id="p2Type" style="display:none;"></span>
                    <div class="player-balls" id="p2Balls"></div>
                </div>
            </div>
            
            <div class="shot-info">
                <span>üéØ Balls Remaining: <span id="ballsRemaining">7</span></span>
                <span>üí• Shot Power: <span id="shotPower">0</span>%</span>
            </div>
            
            <div class="game-message" id="message">Click and drag from cue ball to shoot!</div>
            
            <div class="spin-control">
                <span class="spin-label">Spin:</span>
                <div class="spin-pad" id="spinPad">
                    <div class="spin-dot" id="spinDot"></div>
                </div>
                <span class="spin-label" id="spinInfo">Center</span>
            </div>
            
            <div class="power-bar">
                <div class="power-fill" id="powerFill"></div>
            </div>
            
            <div class="pool-table" id="poolTable">
                <div class="pocket tl"></div>
                <div class="pocket tr"></div>
                <div class="pocket bl"></div>
                <div class="pocket br"></div>
                <div class="pocket ml"></div>
                <div class="pocket mr"></div>
                <canvas id="gameCanvas" width="800" height="400"></canvas>
            </div>
            
            <button id="newGameBtn" class="btn btn-primary">New Game</button>
            
            <div class="instructions">
                <h3>How to Play</h3>
                <p>Click and drag from the white cue ball to aim.<br>
                Release to shoot - drag distance controls power.<br>
                Pocket all your balls (solids/stripes) then the 8 ball!</p>
            </div>
        </div>
    </div>

    <div id="gameOverOverlay" class="game-over-overlay hidden">
        <div class="game-over-content">
            <h2 id="winnerText">Player 1 Wins!</h2>
            <p id="winMessage">All balls pocketed!</p>
            <button id="playAgainBtn" class="btn btn-primary">Play Again</button>
        </div>
    </div>

    <script>
        // Fullscreen
        document.getElementById('fullscreenBtn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const powerFill = document.getElementById('powerFill');
        const message = document.getElementById('message');
        
        const W = canvas.width;
        const H = canvas.height;
        const BALL_RADIUS = 12;
        const FRICTION = 0.985;
        const POCKET_RADIUS = 20;
        
        const POCKETS = [
            { x: 15, y: 15 },
            { x: W - 15, y: 15 },
            { x: 15, y: H - 15 },
            { x: W - 15, y: H - 15 },
            { x: 0, y: H / 2 },
            { x: W, y: H / 2 }
        ];
        
        const BALL_COLORS = {
            cue: '#ffffff',
            1: '#ffd700', 2: '#0000ff', 3: '#ff0000', 4: '#800080',
            5: '#ffa500', 6: '#008000', 7: '#8b0000', 8: '#000000',
            9: '#ffd700', 10: '#0000ff', 11: '#ff0000', 12: '#800080',
            13: '#ffa500', 14: '#008000', 15: '#8b0000'
        };
        
        function getCanvasCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        // Particles for effects
        let particles = [];
        
        // Spin control
        let spin = { x: 0, y: 0 };
        let spinDragging = false;
        
        let balls = [];
        let cueBall = null;
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let dragEnd = { x: 0, y: 0 };
        let currentPlayer = 1;
        let playerTypes = { 1: null, 2: null }; // 'solid' or 'stripe'
        let pocketed = { 1: [], 2: [] };
        let gameMode = '2player';
        let difficulty = 'medium';
        let gameActive = true;
        let ballsMoving = false;
        let foul = false;
        let firstHit = null;
        
        function createBall(x, y, number) {
            return {
                x, y,
                vx: 0, vy: 0,
                number,
                color: BALL_COLORS[number] || BALL_COLORS.cue,
                isStripe: number > 8,
                pocketed: false
            };
        }
        
        function initGame() {
            balls = [];
            pocketed = { 1: [], 2: [] };
            playerTypes = { 1: null, 2: null };
            currentPlayer = 1;
            gameActive = true;
            foul = false;
            firstHit = null;
            
            // Cue ball
            cueBall = createBall(200, H / 2, 0);
            balls.push(cueBall);
            
            // Rack balls in triangle
            const startX = 500;
            const startY = H / 2;
            const order = [1, 9, 2, 10, 8, 11, 3, 12, 4, 13, 5, 14, 6, 15, 7];
            let idx = 0;
            
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col <= row; col++) {
                    const x = startX + row * (BALL_RADIUS * 2 + 2);
                    const y = startY + (col - row / 2) * (BALL_RADIUS * 2 + 2);
                    balls.push(createBall(x, y, order[idx++]));
                }
            }
            
            updatePlayerDisplay();
            message.textContent = "Player 1's turn - Click and drag from cue ball!";
        }
        
        function updatePlayerDisplay() {
            document.getElementById('player1').classList.toggle('active', currentPlayer === 1);
            document.getElementById('player2').classList.toggle('active', currentPlayer === 2);
            
            // Show ball type indicators
            const p1Type = document.getElementById('p1Type');
            const p2Type = document.getElementById('p2Type');
            
            if (playerTypes[1]) {
                p1Type.style.display = 'inline-block';
                p1Type.textContent = playerTypes[1] === 'solid' ? 'Solids (1-7)' : 'Stripes (9-15)';
                p1Type.className = 'ball-type-indicator ' + playerTypes[1];
            } else {
                p1Type.style.display = 'none';
            }
            
            if (playerTypes[2]) {
                p2Type.style.display = 'inline-block';
                p2Type.textContent = playerTypes[2] === 'solid' ? 'Solids (1-7)' : 'Stripes (9-15)';
                p2Type.className = 'ball-type-indicator ' + playerTypes[2];
            } else {
                p2Type.style.display = 'none';
            }
            
            const p1Balls = document.getElementById('p1Balls');
            const p2Balls = document.getElementById('p2Balls');
            p1Balls.innerHTML = '';
            p2Balls.innerHTML = '';
            
            // Show pocketed balls for each player
            const allPocketed1 = balls.filter(b => b.pocketed && b.number !== 0 && b.number !== 8 && 
                playerTypes[1] === (b.number <= 7 ? 'solid' : 'stripe'));
            const allPocketed2 = balls.filter(b => b.pocketed && b.number !== 0 && b.number !== 8 && 
                playerTypes[2] === (b.number <= 7 ? 'solid' : 'stripe'));
            
            allPocketed1.forEach(b => {
                const div = document.createElement('div');
                div.className = `mini-ball ${b.number <= 7 ? 'solid' : 'stripe'}`;
                div.style.background = BALL_COLORS[b.number];
                p1Balls.appendChild(div);
            });
            
            allPocketed2.forEach(b => {
                const div = document.createElement('div');
                div.className = `mini-ball ${b.number <= 7 ? 'solid' : 'stripe'}`;
                div.style.background = BALL_COLORS[b.number];
                p2Balls.appendChild(div);
            });
            
            // Update balls remaining
            const currentType = playerTypes[currentPlayer];
            if (currentType) {
                const remaining = balls.filter(b => !b.pocketed && b.number !== 0 && b.number !== 8 &&
                    (currentType === 'solid' ? b.number <= 7 : b.number > 8)).length;
                document.getElementById('ballsRemaining').textContent = remaining;
            } else {
                document.getElementById('ballsRemaining').textContent = '?';
            }
        }
        
        function createParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8 - 2,
                    life: 40,
                    color,
                    size: Math.random() * 4 + 2
                });
            }
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life--;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }
        
        function update() {
            ballsMoving = false;
            
            for (const ball of balls) {
                if (ball.pocketed) continue;
                
                ball.x += ball.vx;
                ball.y += ball.vy;
                ball.vx *= FRICTION;
                ball.vy *= FRICTION;

                // Apply spin effect
                if (ball.spinX || ball.spinY) {
                    ball.vx += ball.spinX * 0.05;
                    ball.vy += ball.spinY * 0.05;
                    ball.spinX *= 0.98;
                    ball.spinY *= 0.98;
                    if (Math.abs(ball.spinX) < 0.01) ball.spinX = 0;
                    if (Math.abs(ball.spinY) < 0.01) ball.spinY = 0;
                }

                if (Math.abs(ball.vx) < 0.1 && Math.abs(ball.vy) < 0.1) {
                    ball.vx = 0;
                    ball.vy = 0;
                } else {
                    ballsMoving = true;
                }
                
                // Wall collisions
                if (ball.x < BALL_RADIUS) { ball.x = BALL_RADIUS; ball.vx = -ball.vx * 0.8; }
                if (ball.x > W - BALL_RADIUS) { ball.x = W - BALL_RADIUS; ball.vx = -ball.vx * 0.8; }
                if (ball.y < BALL_RADIUS) { ball.y = BALL_RADIUS; ball.vy = -ball.vy * 0.8; }
                if (ball.y > H - BALL_RADIUS) { ball.y = H - BALL_RADIUS; ball.vy = -ball.vy * 0.8; }
                
                // Pocket check
                for (const pocket of POCKETS) {
                    const dx = ball.x - pocket.x;
                    const dy = ball.y - pocket.y;
                    if (Math.sqrt(dx * dx + dy * dy) < POCKET_RADIUS) {
                        handlePocket(ball);
                        break;
                    }
                }
            }
            
            // Ball-ball collisions
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const b1 = balls[i];
                    const b2 = balls[j];
                    if (b1.pocketed || b2.pocketed) continue;
                    
                    const dx = b2.x - b1.x;
                    const dy = b2.y - b1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < BALL_RADIUS * 2) {
                        // Track first hit
                        if ((b1 === cueBall || b2 === cueBall) && firstHit === null) {
                            firstHit = b1 === cueBall ? b2 : b1;
                        }
                        
                        // Collision response
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const dvx = b1.vx - b2.vx;
                        const dvy = b1.vy - b2.vy;
                        const dvn = dvx * nx + dvy * ny;
                        
                        if (dvn > 0) {
                            b1.vx -= dvn * nx;
                            b1.vy -= dvn * ny;
                            b2.vx += dvn * nx;
                            b2.vy += dvn * ny;
                            
                            // Separate balls
                            const overlap = BALL_RADIUS * 2 - dist;
                            b1.x -= overlap / 2 * nx;
                            b1.y -= overlap / 2 * ny;
                            b2.x += overlap / 2 * nx;
                            b2.y += overlap / 2 * ny;
                        }
                    }
                }
            }
        }
        
        function handlePocket(ball) {
            ball.pocketed = true;
            ball.vx = 0;
            ball.vy = 0;
            
            // Create pocket particles
            createParticles(ball.x, ball.y, ball.color, 15);
            
            if (ball === cueBall) {
                foul = true;
                message.textContent = '‚ö†Ô∏è Scratch! Cue ball pocketed!';
                setTimeout(() => {
                    ball.pocketed = false;
                    ball.x = 200;
                    ball.y = H / 2;
                }, 500);
                return;
            }
            
            if (ball.number === 8) {
                // Check if player can pocket 8 ball
                const playerType = playerTypes[currentPlayer];
                const remaining = balls.filter(b => !b.pocketed && b.number !== 0 && b.number !== 8 &&
                    (playerType === 'solid' ? b.number <= 7 : b.number > 8));
                
                if (remaining.length > 0 || foul) {
                    endGame(currentPlayer === 1 ? 2 : 1, 'Pocketed 8 ball early!');
                } else {
                    endGame(currentPlayer, 'All balls pocketed!');
                }
                return;
            }
            
            // Assign type if not assigned
            if (!playerTypes[1]) {
                if (ball.number <= 7) {
                    playerTypes[currentPlayer] = 'solid';
                    playerTypes[currentPlayer === 1 ? 2 : 1] = 'stripe';
                } else {
                    playerTypes[currentPlayer] = 'stripe';
                    playerTypes[currentPlayer === 1 ? 2 : 1] = 'solid';
                }
            }
            
            pocketed[currentPlayer].push(ball.number);
            updatePlayerDisplay();
        }
        
        function endTurn() {
            const playerType = playerTypes[currentPlayer];
            let pocketedOwn = false;

            if (playerType && pocketed[currentPlayer].length > 0) {
                pocketedOwn = pocketed[currentPlayer].some(num =>
                    (playerType === 'solid' && num >= 1 && num <= 7) ||
                    (playerType === 'stripe' && num >= 9 && num <= 15)
                );
            } else if (!playerType && pocketed[currentPlayer].length > 0) {
                pocketedOwn = true;
            }

            let wrongFirstHit = false;
            if (firstHit && playerType) {
                if (playerType === 'solid' && firstHit.number > 7 && firstHit.number !== 8) wrongFirstHit = true;
                if (playerType === 'stripe' && firstHit.number <= 7) wrongFirstHit = true;
            }
            if (!firstHit && !foul && playerType) {
                foul = true;
            }

            if (foul || wrongFirstHit) {
                message.textContent = `Foul! Player ${currentPlayer === 1 ? 2 : 1}'s turn`;
                currentPlayer = currentPlayer === 1 ? 2 : 1;
            } else if (!pocketedOwn) {
                currentPlayer = currentPlayer === 1 ? 2 : 1;
                message.textContent = `Player ${currentPlayer}'s turn`;
            } else {
                message.textContent = `Player ${currentPlayer} continues!`;
            }

            foul = false;
            firstHit = null;
            pocketed = { 1: [], 2: [] };
            updatePlayerDisplay();

            if (gameMode === 'ai' && currentPlayer === 2 && gameActive) {
                setTimeout(aiShoot, 1000);
            }
        }
        
        function endGame(winner, reason) {
            gameActive = false;
            document.getElementById('winnerText').textContent = 
                `${winner === 1 ? 'Player 1' : (gameMode === 'ai' ? 'AI' : 'Player 2')} Wins!`;
            document.getElementById('winMessage').textContent = reason;
            document.getElementById('gameOverOverlay').classList.remove('hidden');
        }
        
        function aiShoot() {
            if (!gameActive || ballsMoving) return;

            const myType = playerTypes[2];
            const myBallsLeft = balls.filter(b => !b.pocketed && b.number !== 0 && b.number !== 8 &&
                (myType === 'solid' ? b.number <= 7 : b.number > 8));

            let shotTargets;
            if (myType && myBallsLeft.length === 0) {
                shotTargets = balls.filter(b => !b.pocketed && b.number === 8);
            } else {
                shotTargets = balls.filter(b => !b.pocketed && b.number !== 0 && b.number !== 8 &&
                    (myType === null ||
                     (myType === 'solid' && b.number <= 7) ||
                     (myType === 'stripe' && b.number > 8)));
            }

            if (shotTargets.length === 0) {
                shotTargets = balls.filter(b => !b.pocketed && b.number !== 0);
            }
            if (shotTargets.length === 0) return;

            let bestShot = null;
            let bestScore = -Infinity;

            for (const target of shotTargets) {
                for (const pocket of POCKETS) {
                    const tpx = pocket.x - target.x;
                    const tpy = pocket.y - target.y;
                    const tpDist = Math.sqrt(tpx * tpx + tpy * tpy);

                    const ghostX = target.x - (tpx / tpDist) * BALL_RADIUS * 2;
                    const ghostY = target.y - (tpy / tpDist) * BALL_RADIUS * 2;

                    const cueDist = Math.sqrt(Math.pow(ghostX - cueBall.x, 2) + Math.pow(ghostY - cueBall.y, 2));

                    const pathClear = isPathClear(cueBall.x, cueBall.y, ghostX, ghostY, [target]);

                    let score = 0;
                    if (pathClear) score += 500;
                    score -= tpDist * 0.5;
                    score -= cueDist * 0.3;

                    const cueToDx = ghostX - cueBall.x;
                    const cueToDy = ghostY - cueBall.y;
                    const cueToLen = Math.sqrt(cueToDx * cueToDx + cueToDy * cueToDy);
                    if (cueToLen > 0) {
                        const dot = (cueToDx / cueToLen) * (tpx / tpDist) + (cueToDy / cueToLen) * (tpy / tpDist);
                        score += dot * 200;
                    }

                    if (score > bestScore) {
                        bestScore = score;
                        bestShot = { target, pocket, ghostX, ghostY };
                    }
                }
            }

            if (!bestShot) return;

            let dx = bestShot.ghostX - cueBall.x;
            let dy = bestShot.ghostY - cueBall.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            let inaccuracy = 0;
            if (difficulty === 'easy') inaccuracy = (Math.random() - 0.5) * 0.4;
            else if (difficulty === 'medium') inaccuracy = (Math.random() - 0.5) * 0.15;
            else inaccuracy = (Math.random() - 0.5) * 0.05;

            const angle = Math.atan2(dy, dx) + inaccuracy;
            let power = Math.min(15, Math.max(5, dist / 30));
            if (difficulty === 'easy') power *= 0.7 + Math.random() * 0.3;
            else if (difficulty === 'medium') power *= 0.85 + Math.random() * 0.15;

            cueBall.vx = Math.cos(angle) * power;
            cueBall.vy = Math.sin(angle) * power;

            message.textContent = 'AI is shooting...';
        }

        function isPathClear(x1, y1, x2, y2, excludeBalls) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist === 0) return true;
            const nx = dx / dist;
            const ny = dy / dist;

            for (const ball of balls) {
                if (ball === cueBall || ball.pocketed || excludeBalls.includes(ball)) continue;
                const bx = ball.x - x1;
                const by = ball.y - y1;
                const proj = bx * nx + by * ny;
                if (proj < 0 || proj > dist) continue;
                const perpDist = Math.abs(bx * ny - by * nx);
                if (perpDist < BALL_RADIUS * 2.5) return false;
            }
            return true;
        }
        
        function draw() {
            ctx.clearRect(0, 0, W, H);

            // Draw table markings
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(W * 0.25, 0);
            ctx.lineTo(W * 0.25, H);
            ctx.stroke();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.beginPath();
            ctx.arc(W * 0.25, H / 2, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(W * 0.625, H / 2, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw trajectory prediction when aiming
            if (isDragging && !ballsMoving) {
                const dx = dragStart.x - dragEnd.x;
                const dy = dragStart.y - dragEnd.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 5) {
                    const nx = dx / dist;
                    const ny = dy / dist;
                    
                    // Find first ball in trajectory
                    let closestDist = Infinity;
                    let hitPoint = null;
                    
                    for (let t = 0; t < 500; t += 2) {
                        const px = cueBall.x + nx * t;
                        const py = cueBall.y + ny * t;
                        
                        // Check walls
                        if (px < BALL_RADIUS || px > W - BALL_RADIUS || py < BALL_RADIUS || py > H - BALL_RADIUS) {
                            hitPoint = { x: px, y: py };
                            break;
                        }
                        
                        // Check balls
                        for (const ball of balls) {
                            if (ball === cueBall || ball.pocketed) continue;
                            const bdx = px - ball.x;
                            const bdy = py - ball.y;
                            if (Math.sqrt(bdx * bdx + bdy * bdy) < BALL_RADIUS * 2) {
                                hitPoint = { x: px, y: py, ball };
                                break;
                            }
                        }
                        if (hitPoint) break;
                    }
                    
                    // Draw dotted trajectory line
                    ctx.beginPath();
                    ctx.setLineDash([8, 8]);
                    ctx.moveTo(cueBall.x, cueBall.y);
                    if (hitPoint) {
                        ctx.lineTo(hitPoint.x, hitPoint.y);
                        
                        // Draw ghost ball
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.setLineDash([]);
                        ctx.arc(hitPoint.x, hitPoint.y, BALL_RADIUS, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.stroke();
                        
                        // Show predicted ball direction
                        if (hitPoint.ball) {
                            const bdx = hitPoint.ball.x - hitPoint.x;
                            const bdy = hitPoint.ball.y - hitPoint.y;
                            const bdist = Math.sqrt(bdx * bdx + bdy * bdy);
                            
                            ctx.beginPath();
                            ctx.setLineDash([4, 4]);
                            ctx.moveTo(hitPoint.ball.x, hitPoint.ball.y);
                            ctx.lineTo(hitPoint.ball.x + (bdx / bdist) * 60, hitPoint.ball.y + (bdy / bdist) * 60);
                            ctx.strokeStyle = 'rgba(0, 255, 136, 0.5)';
                            ctx.stroke();
                        }
                    } else {
                        ctx.lineTo(cueBall.x + nx * 500, cueBall.y + ny * 500);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                    ctx.setLineDash([]);
                }
            }
            
            // Draw particles
            for (const p of particles) {
                ctx.globalAlpha = p.life / 40;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            
            // Draw balls
            for (const ball of balls) {
                if (ball.pocketed) continue;
                
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI * 2);
                
                if (ball.isStripe) {
                    ctx.fillStyle = '#fff';
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(ball.x, ball.y, BALL_RADIUS, Math.PI * 0.3, Math.PI * 0.7);
                    ctx.arc(ball.x, ball.y, BALL_RADIUS, Math.PI * 1.3, Math.PI * 1.7);
                    ctx.fillStyle = ball.color;
                    ctx.fill();
                } else {
                    ctx.fillStyle = ball.color;
                    ctx.fill();
                }
                
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Ball number
                if (ball.number > 0) {
                    ctx.beginPath();
                    ctx.arc(ball.x, ball.y, 6, 0, Math.PI * 2);
                    ctx.fillStyle = '#fff';
                    ctx.fill();
                    
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 8px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(ball.number, ball.x, ball.y);
                }
                
                // Highlight
                ctx.beginPath();
                ctx.arc(ball.x - 3, ball.y - 3, 4, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.fill();
            }
            
            // Draw aiming line
            if (isDragging && !ballsMoving) {
                ctx.beginPath();
                ctx.moveTo(cueBall.x, cueBall.y);
                ctx.lineTo(cueBall.x - (dragEnd.x - dragStart.x), cueBall.y - (dragEnd.y - dragStart.y));
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw cue stick
                const dx = dragStart.x - dragEnd.x;
                const dy = dragStart.y - dragEnd.y;
                const angle = Math.atan2(dy, dx);
                const dist = Math.min(100, Math.sqrt(dx * dx + dy * dy));
                
                ctx.save();
                ctx.translate(cueBall.x, cueBall.y);
                ctx.rotate(angle);
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(BALL_RADIUS + dist / 3, -3, 150, 6);
                ctx.restore();
            }
        }
        
        function gameLoop() {
            if (gameActive) {
                const wasMoving = ballsMoving;
                update();
                updateParticles();
                if (wasMoving && !ballsMoving) {
                    endTurn();
                }
            }
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Input handlers
        canvas.addEventListener('mousedown', (e) => {
            if (ballsMoving || !gameActive) return;
            if (gameMode === 'ai' && currentPlayer === 2) return;

            const { x, y } = getCanvasCoords(e);
            
            const dx = x - cueBall.x;
            const dy = y - cueBall.y;
            if (Math.sqrt(dx * dx + dy * dy) < BALL_RADIUS * 3) {
                isDragging = true;
                dragStart = { x, y };
                dragEnd = { x, y };
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const { x, y } = getCanvasCoords(e);
            dragEnd = { x, y };
            
            const dist = Math.sqrt(Math.pow(dragEnd.x - dragStart.x, 2) + Math.pow(dragEnd.y - dragStart.y, 2));
            const power = Math.min(100, dist / 2);
            powerFill.style.width = power + '%';
            document.getElementById('shotPower').textContent = Math.round(power);
        });
        
        canvas.addEventListener('mouseup', () => {
            if (!isDragging) return;
            isDragging = false;
            
            const dx = dragStart.x - dragEnd.x;
            const dy = dragStart.y - dragEnd.y;
            const power = Math.min(20, Math.sqrt(dx * dx + dy * dy) / 10);
            
            if (power > 0.5) {
                const dist = Math.sqrt(dx * dx + dy * dy);
                cueBall.vx = (dx / dist) * power;
                cueBall.vy = (dy / dist) * power;
                
                // Apply spin effect (affects curve over time)
                cueBall.spinX = spin.x * 0.3;
                cueBall.spinY = spin.y * 0.3;
            }
            
            powerFill.style.width = '0%';
            document.getElementById('shotPower').textContent = '0';
        });
        
        // Spin control
        const spinPad = document.getElementById('spinPad');
        const spinDot = document.getElementById('spinDot');
        const spinInfo = document.getElementById('spinInfo');
        
        function updateSpinDot() {
            const padSize = 80;
            const dotX = (spin.x + 1) * (padSize / 2);
            const dotY = (spin.y + 1) * (padSize / 2);
            spinDot.style.left = dotX + 'px';
            spinDot.style.top = dotY + 'px';
            
            // Update spin info
            let info = 'Center';
            if (spin.y < -0.3) info = 'Top';
            else if (spin.y > 0.3) info = 'Bottom';
            if (spin.x < -0.3) info = (info === 'Center' ? '' : info + '-') + 'Left';
            else if (spin.x > 0.3) info = (info === 'Center' ? '' : info + '-') + 'Right';
            spinInfo.textContent = info || 'Center';
        }
        
        spinPad.addEventListener('mousedown', (e) => {
            spinDragging = true;
            updateSpin(e);
        });
        
        document.addEventListener('mousemove', (e) => {
            if (spinDragging) updateSpin(e);
        });
        
        document.addEventListener('mouseup', () => {
            spinDragging = false;
        });
        
        function updateSpin(e) {
            const rect = spinPad.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width * 2 - 1;
            const y = (e.clientY - rect.top) / rect.height * 2 - 1;
            spin.x = Math.max(-1, Math.min(1, x));
            spin.y = Math.max(-1, Math.min(1, y));
            updateSpinDot();
        }
        
        // Reset spin on double click
        spinPad.addEventListener('dblclick', () => {
            spin = { x: 0, y: 0 };
            updateSpinDot();
        });
        
        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (touch.clientX - rect.left) * scaleX;
            const y = (touch.clientY - rect.top) * scaleY;

            if (ballsMoving || !gameActive) return;
            if (gameMode === 'ai' && currentPlayer === 2) return;
            
            const dx = x - cueBall.x;
            const dy = y - cueBall.y;
            if (Math.sqrt(dx * dx + dy * dy) < BALL_RADIUS * 5) {
                isDragging = true;
                dragStart = { x, y };
                dragEnd = { x, y };
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isDragging) return;
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            dragEnd = { x: (touch.clientX - rect.left) * scaleX, y: (touch.clientY - rect.top) * scaleY };
            
            const dist = Math.sqrt(Math.pow(dragEnd.x - dragStart.x, 2) + Math.pow(dragEnd.y - dragStart.y, 2));
            powerFill.style.width = Math.min(100, dist / 2) + '%';
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (!isDragging) return;
            isDragging = false;
            
            const dx = dragStart.x - dragEnd.x;
            const dy = dragStart.y - dragEnd.y;
            const power = Math.min(20, Math.sqrt(dx * dx + dy * dy) / 10);
            
            if (power > 0.5) {
                const dist = Math.sqrt(dx * dx + dy * dy);
                cueBall.vx = (dx / dist) * power;
                cueBall.vy = (dy / dist) * power;
            }
            
            powerFill.style.width = '0%';
        });
        
        // UI handlers
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameMode = btn.dataset.mode;
                document.getElementById('difficultyContainer').classList.toggle('hidden', gameMode !== 'ai');
                document.getElementById('p2Name').textContent = gameMode === 'ai' ? 'AI' : 'Player 2';
                initGame();
            });
        });
        
        document.querySelectorAll('.diff-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                difficulty = btn.dataset.difficulty;
            });
        });
        
        document.getElementById('newGameBtn').addEventListener('click', initGame);
        document.getElementById('playAgainBtn').addEventListener('click', () => {
            document.getElementById('gameOverOverlay').classList.add('hidden');
            initGame();
        });
        
        initGame();
        gameLoop();
    </script>
    <script src="../js/game-utils.js"></script>
    <script src="../js/accounts.js"></script>
</body>
</html>
