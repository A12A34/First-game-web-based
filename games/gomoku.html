<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gomoku - Game Hub</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../css/styles.css">
    <style>
        .gomoku-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .game-mode {
            display: flex;
            gap: 10px;
            margin-bottom: 5px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .mode-btn {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.95rem;
        }
        .mode-btn.active {
            background: linear-gradient(45deg, #00d9ff, #00ff88);
            color: #1a1a2e;
            border-color: transparent;
            font-weight: bold;
        }
        .mode-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.2);
        }
        .difficulty-selection {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .difficulty-selection.hidden {
            display: none !important;
        }
        .diff-btn {
            padding: 8px 18px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            color: #ccc;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.85rem;
        }
        .diff-btn.active {
            background: rgba(0, 217, 255, 0.25);
            border-color: #00d9ff;
            color: #00d9ff;
            font-weight: bold;
        }
        .diff-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.15);
        }
        .player-info {
            display: flex;
            gap: 30px;
            margin: 5px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        .player-box {
            padding: 12px 25px;
            border-radius: 10px;
            text-align: center;
            transition: all 0.3s;
            min-width: 130px;
        }
        .player-box.black-stone {
            background: rgba(100, 100, 100, 0.3);
            border: 2px solid #888;
        }
        .player-box.white-stone {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #ccc;
        }
        .player-box.active {
            transform: scale(1.08);
            box-shadow: 0 0 20px rgba(0, 217, 255, 0.5);
            border-color: #00d9ff;
        }
        .player-name {
            font-weight: bold;
            font-size: 1rem;
        }
        .player-score {
            font-size: 1.4rem;
            font-weight: bold;
            margin-top: 4px;
            color: #00ff88;
        }
        .message {
            font-size: 1.4rem;
            font-weight: bold;
            min-height: 36px;
            text-align: center;
            color: #00d9ff;
        }
        .canvas-wrapper {
            position: relative;
            display: inline-block;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }
        #gomokuCanvas {
            display: block;
            cursor: pointer;
            border-radius: 12px;
        }
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 8px;
            padding: 10px 15px;
            cursor: pointer;
            font-size: 1.5rem;
            transition: all 0.3s;
        }
        .fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        .instructions {
            max-width: 500px;
        }
        @media (max-width: 600px) {
            .player-info {
                gap: 15px;
            }
            .player-box {
                padding: 10px 18px;
                min-width: 110px;
            }
            .message {
                font-size: 1.1rem;
            }
        }
    </style>
</head>
<body>
    <button id="fullscreenBtn" class="fullscreen-btn" title="Toggle Fullscreen">&#x26F6;</button>
    <div class="container">
        <a href="../index.html" class="back-btn">&larr; Back to Games</a>

        <div class="game-container">
            <h1 class="game-title">&#9898;&#9899; Gomoku</h1>

            <div class="gomoku-container">
                <div class="game-mode">
                    <button class="mode-btn active" data-mode="pvp">2 Players</button>
                    <button class="mode-btn" data-mode="ai">vs AI</button>
                </div>

                <div class="difficulty-selection hidden" id="difficultySelection">
                    <button class="diff-btn active" data-diff="easy">Easy</button>
                    <button class="diff-btn" data-diff="hard">Hard</button>
                </div>

                <div class="player-info">
                    <div class="player-box black-stone active" id="player1">
                        <div class="player-name">&#9899; Black</div>
                        <div class="player-score" id="score1">0</div>
                    </div>
                    <div class="player-box white-stone" id="player2">
                        <div class="player-name">&#9898; White</div>
                        <div class="player-score" id="score2">0</div>
                    </div>
                </div>

                <div class="message" id="message">Black's turn</div>

                <div class="canvas-wrapper">
                    <canvas id="gomokuCanvas"></canvas>
                </div>

                <div class="controls">
                    <button id="newGameBtn" class="btn btn-primary">New Game</button>
                    <button id="undoBtn" class="btn btn-secondary">Undo</button>
                </div>
            </div>

            <div class="instructions">
                <h3>How to Play</h3>
                <p>Players take turns placing black and white stones on the intersections of a 15&times;15 grid.
                   The first player to get exactly <strong>5 stones in a row</strong> &mdash; horizontally, vertically,
                   or diagonally &mdash; wins the game. Plan ahead, block your opponent, and build your lines to victory!</p>
            </div>
        </div>
    </div>

    <script>
        // ========== CONSTANTS ==========
        const BOARD_SIZE = 15;
        const EMPTY = 0;
        const BLACK = 1;
        const WHITE = 2;

        // ========== STATE ==========
        let board = [];
        let currentPlayer = BLACK;
        let gameOver = false;
        let vsAI = false;
        let aiDifficulty = 'easy';
        let scores = [0, 0];
        let moveHistory = [];
        let lastMove = null;
        let winningCells = [];
        let hoverPos = null;
        let aiThinking = false;

        // ========== CANVAS SETUP ==========
        const canvas = document.getElementById('gomokuCanvas');
        const ctx = canvas.getContext('2d');
        const messageEl = document.getElementById('message');
        const player1Box = document.getElementById('player1');
        const player2Box = document.getElementById('player2');

        // Board drawing parameters - recomputed on resize
        let cellSize, padding, boardPixelSize, canvasSize;

        function computeSizes() {
            const maxWidth = Math.min(window.innerWidth - 40, 620);
            canvasSize = Math.max(320, maxWidth);
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            padding = Math.round(canvasSize * 0.045);
            boardPixelSize = canvasSize - padding * 2;
            cellSize = boardPixelSize / (BOARD_SIZE - 1);
        }

        // ========== INITIALIZATION ==========
        function init() {
            computeSizes();
            newGame();

            // Mode buttons
            document.querySelectorAll('.game-mode .mode-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.game-mode .mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    vsAI = btn.dataset.mode === 'ai';
                    const diffSel = document.getElementById('difficultySelection');
                    if (vsAI) {
                        diffSel.classList.remove('hidden');
                        document.querySelector('#player2 .player-name').innerHTML = '&#9898; AI';
                    } else {
                        diffSel.classList.add('hidden');
                        document.querySelector('#player2 .player-name').innerHTML = '&#9898; White';
                    }
                    scores = [0, 0];
                    updateScores();
                    newGame();
                });
            });

            // Difficulty buttons
            document.querySelectorAll('.diff-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    aiDifficulty = btn.dataset.diff;
                    newGame();
                });
            });

            document.getElementById('newGameBtn').addEventListener('click', () => newGame());
            document.getElementById('undoBtn').addEventListener('click', undoMove);
            document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);

            canvas.addEventListener('click', handleClick);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseleave', () => { hoverPos = null; drawBoard(); });

            window.addEventListener('resize', () => {
                computeSizes();
                drawBoard();
            });
        }

        function newGame() {
            board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(EMPTY));
            currentPlayer = BLACK;
            gameOver = false;
            moveHistory = [];
            lastMove = null;
            winningCells = [];
            hoverPos = null;
            aiThinking = false;
            updateTurnMessage();
            updatePlayerIndicator();
            drawBoard();
        }

        // ========== DRAWING ==========
        function drawBoard() {
            ctx.clearRect(0, 0, canvasSize, canvasSize);

            // Board background - warm wood color
            const bgGrad = ctx.createLinearGradient(0, 0, canvasSize, canvasSize);
            bgGrad.addColorStop(0, '#d4a653');
            bgGrad.addColorStop(1, '#c49340');
            ctx.fillStyle = bgGrad;
            ctx.beginPath();
            ctx.roundRect(0, 0, canvasSize, canvasSize, 12);
            ctx.fill();

            // Grid lines
            ctx.strokeStyle = '#5c3d1a';
            ctx.lineWidth = Math.max(1, cellSize * 0.02);
            for (let i = 0; i < BOARD_SIZE; i++) {
                const pos = padding + i * cellSize;
                // Horizontal
                ctx.beginPath();
                ctx.moveTo(padding, pos);
                ctx.lineTo(padding + boardPixelSize, pos);
                ctx.stroke();
                // Vertical
                ctx.beginPath();
                ctx.moveTo(pos, padding);
                ctx.lineTo(pos, padding + boardPixelSize);
                ctx.stroke();
            }

            // Star points (hoshi)
            const starPoints = [3, 7, 11];
            ctx.fillStyle = '#5c3d1a';
            for (const r of starPoints) {
                for (const c of starPoints) {
                    const x = padding + c * cellSize;
                    const y = padding + r * cellSize;
                    ctx.beginPath();
                    ctx.arc(x, y, Math.max(3, cellSize * 0.09), 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Hover indicator
            if (hoverPos && !gameOver && !aiThinking) {
                const { row, col } = hoverPos;
                if (board[row][col] === EMPTY) {
                    const x = padding + col * cellSize;
                    const y = padding + row * cellSize;
                    const radius = cellSize * 0.42;
                    ctx.globalAlpha = 0.35;
                    drawStone(x, y, radius, currentPlayer);
                    ctx.globalAlpha = 1.0;
                }
            }

            // Stones
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== EMPTY) {
                        const x = padding + c * cellSize;
                        const y = padding + r * cellSize;
                        const radius = cellSize * 0.42;
                        drawStone(x, y, radius, board[r][c]);
                    }
                }
            }

            // Last move marker
            if (lastMove) {
                const x = padding + lastMove.col * cellSize;
                const y = padding + lastMove.row * cellSize;
                const markerColor = board[lastMove.row][lastMove.col] === BLACK ? '#ff4444' : '#ff4444';
                ctx.strokeStyle = '#ff3333';
                ctx.lineWidth = Math.max(2, cellSize * 0.06);
                const mSize = cellSize * 0.15;
                ctx.beginPath();
                ctx.moveTo(x - mSize, y - mSize);
                ctx.lineTo(x + mSize, y + mSize);
                ctx.moveTo(x + mSize, y - mSize);
                ctx.lineTo(x - mSize, y + mSize);
                ctx.stroke();
            }

            // Winning line highlight
            if (winningCells.length > 0) {
                // Glow behind winning stones
                for (const [r, c] of winningCells) {
                    const x = padding + c * cellSize;
                    const y = padding + r * cellSize;
                    ctx.shadowColor = '#00ff88';
                    ctx.shadowBlur = 18;
                    ctx.strokeStyle = '#00ff88';
                    ctx.lineWidth = Math.max(2.5, cellSize * 0.07);
                    ctx.beginPath();
                    ctx.arc(x, y, cellSize * 0.46, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // Line connecting winning stones
                if (winningCells.length >= 2) {
                    const first = winningCells[0];
                    const last = winningCells[winningCells.length - 1];
                    const x1 = padding + first[1] * cellSize;
                    const y1 = padding + first[0] * cellSize;
                    const x2 = padding + last[1] * cellSize;
                    const y2 = padding + last[0] * cellSize;
                    ctx.strokeStyle = 'rgba(0, 255, 136, 0.6)';
                    ctx.lineWidth = Math.max(3, cellSize * 0.1);
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            }
        }

        function drawStone(x, y, radius, player) {
            if (player === BLACK) {
                const grad = ctx.createRadialGradient(x - radius * 0.3, y - radius * 0.3, radius * 0.1, x, y, radius);
                grad.addColorStop(0, '#555');
                grad.addColorStop(0.6, '#222');
                grad.addColorStop(1, '#111');
                ctx.fillStyle = grad;
            } else {
                const grad = ctx.createRadialGradient(x - radius * 0.3, y - radius * 0.3, radius * 0.1, x, y, radius);
                grad.addColorStop(0, '#ffffff');
                grad.addColorStop(0.6, '#e8e8e8');
                grad.addColorStop(1, '#c0c0c0');
                ctx.fillStyle = grad;
            }

            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();

            // Subtle border
            ctx.strokeStyle = player === BLACK ? '#000' : '#999';
            ctx.lineWidth = Math.max(0.5, cellSize * 0.015);
            ctx.stroke();
        }

        // ========== INPUT HANDLING ==========
        function getGridPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mx = (e.clientX - rect.left) * scaleX;
            const my = (e.clientY - rect.top) * scaleY;
            const col = Math.round((mx - padding) / cellSize);
            const row = Math.round((my - padding) / cellSize);
            if (row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE) {
                return { row, col };
            }
            return null;
        }

        function handleMouseMove(e) {
            const pos = getGridPos(e);
            if (pos && !gameOver && !aiThinking) {
                hoverPos = pos;
            } else {
                hoverPos = null;
            }
            drawBoard();
        }

        function handleClick(e) {
            if (gameOver || aiThinking) return;
            if (vsAI && currentPlayer === WHITE) return;

            const pos = getGridPos(e);
            if (!pos) return;
            const { row, col } = pos;

            if (board[row][col] !== EMPTY) return;

            placeStone(row, col);
        }

        function placeStone(row, col) {
            board[row][col] = currentPlayer;
            moveHistory.push({ row, col, player: currentPlayer });
            lastMove = { row, col };

            // Check for win
            const winResult = checkWin(row, col, currentPlayer);
            if (winResult) {
                winningCells = winResult;
                gameOver = true;
                const winnerIdx = currentPlayer === BLACK ? 0 : 1;
                scores[winnerIdx]++;
                updateScores();
                const name = currentPlayer === BLACK ? 'Black' : (vsAI ? 'AI' : 'White');
                messageEl.textContent = name + ' wins!';
                messageEl.style.color = '#00ff88';
                drawBoard();
                return;
            }

            // Check for draw
            if (moveHistory.length === BOARD_SIZE * BOARD_SIZE) {
                gameOver = true;
                messageEl.textContent = "It's a draw!";
                messageEl.style.color = '#ffd93d';
                drawBoard();
                return;
            }

            // Switch turns
            currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
            updateTurnMessage();
            updatePlayerIndicator();
            drawBoard();

            // AI move
            if (vsAI && currentPlayer === WHITE && !gameOver) {
                aiThinking = true;
                messageEl.textContent = 'AI is thinking...';
                setTimeout(() => {
                    const move = getAIMove();
                    aiThinking = false;
                    if (move) {
                        placeStone(move.row, move.col);
                    }
                }, 200);
            }
        }

        // ========== UNDO ==========
        function undoMove() {
            if (moveHistory.length === 0 || gameOver) return;

            // In AI mode, undo two moves (AI + player)
            const steps = vsAI && moveHistory.length >= 2 ? 2 : 1;
            for (let i = 0; i < steps; i++) {
                if (moveHistory.length === 0) break;
                const move = moveHistory.pop();
                board[move.row][move.col] = EMPTY;
            }

            currentPlayer = moveHistory.length > 0 ? (moveHistory[moveHistory.length - 1].player === BLACK ? WHITE : BLACK) : BLACK;
            lastMove = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;
            winningCells = [];
            gameOver = false;
            updateTurnMessage();
            updatePlayerIndicator();
            drawBoard();
        }

        // ========== WIN CHECK ==========
        function checkWin(row, col, player) {
            const directions = [
                [0, 1],   // horizontal
                [1, 0],   // vertical
                [1, 1],   // diagonal down-right
                [1, -1]   // diagonal down-left
            ];

            for (const [dr, dc] of directions) {
                let cells = [[row, col]];

                // Extend in positive direction
                for (let i = 1; i < 5; i++) {
                    const nr = row + dr * i;
                    const nc = col + dc * i;
                    if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE) break;
                    if (board[nr][nc] !== player) break;
                    cells.push([nr, nc]);
                }

                // Extend in negative direction
                for (let i = 1; i < 5; i++) {
                    const nr = row - dr * i;
                    const nc = col - dc * i;
                    if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE) break;
                    if (board[nr][nc] !== player) break;
                    cells.push([nr, nc]);
                }

                if (cells.length >= 5) {
                    // Sort cells for a consistent winning line
                    cells.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
                    return cells;
                }
            }

            return null;
        }

        // ========== AI ==========
        function getAIMove() {
            if (aiDifficulty === 'easy') {
                return getAIMoveEasy();
            } else {
                return getAIMoveHard();
            }
        }

        // --- Easy AI: basic scoring with some randomness ---
        function getAIMoveEasy() {
            let bestScore = -Infinity;
            let bestMoves = [];

            const candidates = getAICandidates();

            for (const { row, col } of candidates) {
                // Score for AI (offensive)
                const attackScore = evaluatePosition(row, col, WHITE);
                // Score for opponent (defensive)
                const defendScore = evaluatePosition(row, col, BLACK);
                const score = Math.max(attackScore, defendScore * 0.9) + Math.random() * 5;

                if (score > bestScore) {
                    bestScore = score;
                    bestMoves = [{ row, col }];
                } else if (Math.abs(score - bestScore) < 1) {
                    bestMoves.push({ row, col });
                }
            }

            if (bestMoves.length === 0) {
                return { row: 7, col: 7 }; // center
            }
            return bestMoves[Math.floor(Math.random() * bestMoves.length)];
        }

        // --- Hard AI: deeper scoring, considers opponent threats aggressively ---
        function getAIMoveHard() {
            let bestScore = -Infinity;
            let bestMove = null;

            const candidates = getAICandidates();

            for (const { row, col } of candidates) {
                // Check if this move wins
                board[row][col] = WHITE;
                if (checkWin(row, col, WHITE)) {
                    board[row][col] = EMPTY;
                    return { row, col };
                }
                board[row][col] = EMPTY;

                // Check if opponent wins here (must block)
                board[row][col] = BLACK;
                if (checkWin(row, col, BLACK)) {
                    board[row][col] = EMPTY;
                    return { row, col };
                }
                board[row][col] = EMPTY;
            }

            for (const { row, col } of candidates) {
                const attackScore = evaluatePositionHard(row, col, WHITE);
                const defendScore = evaluatePositionHard(row, col, BLACK);
                const score = attackScore * 1.1 + defendScore;

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = { row, col };
                }
            }

            return bestMove || { row: 7, col: 7 };
        }

        // Get candidate moves: cells adjacent (within 2) to existing stones
        function getAICandidates() {
            const candidateSet = new Set();
            const radius = 2;

            if (moveHistory.length === 0) {
                return [{ row: 7, col: 7 }];
            }

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== EMPTY) {
                        for (let dr = -radius; dr <= radius; dr++) {
                            for (let dc = -radius; dc <= radius; dc++) {
                                const nr = r + dr;
                                const nc = c + dc;
                                if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === EMPTY) {
                                    candidateSet.add(nr * BOARD_SIZE + nc);
                                }
                            }
                        }
                    }
                }
            }

            return Array.from(candidateSet).map(v => ({
                row: Math.floor(v / BOARD_SIZE),
                col: v % BOARD_SIZE
            }));
        }

        // --- Pattern scoring for Easy AI ---
        function evaluatePosition(row, col, player) {
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
            let totalScore = 0;

            board[row][col] = player;

            for (const [dr, dc] of directions) {
                const { count, openEnds } = countLine(row, col, dr, dc, player);

                if (count >= 5) totalScore += 100000;
                else if (count === 4 && openEnds === 2) totalScore += 10000;
                else if (count === 4 && openEnds === 1) totalScore += 1000;
                else if (count === 3 && openEnds === 2) totalScore += 1000;
                else if (count === 3 && openEnds === 1) totalScore += 100;
                else if (count === 2 && openEnds === 2) totalScore += 100;
                else if (count === 2 && openEnds === 1) totalScore += 10;
                else if (count === 1 && openEnds === 2) totalScore += 5;
            }

            board[row][col] = EMPTY;
            return totalScore;
        }

        // --- Pattern scoring for Hard AI: refined weights ---
        function evaluatePositionHard(row, col, player) {
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
            let totalScore = 0;

            board[row][col] = player;

            for (const [dr, dc] of directions) {
                const { count, openEnds } = countLine(row, col, dr, dc, player);

                if (count >= 5) totalScore += 1000000;
                else if (count === 4 && openEnds === 2) totalScore += 100000;
                else if (count === 4 && openEnds === 1) totalScore += 8000;
                else if (count === 3 && openEnds === 2) totalScore += 8000;
                else if (count === 3 && openEnds === 1) totalScore += 500;
                else if (count === 2 && openEnds === 2) totalScore += 500;
                else if (count === 2 && openEnds === 1) totalScore += 50;
                else if (count === 1 && openEnds === 2) totalScore += 20;
                else if (count === 1 && openEnds === 1) totalScore += 5;
            }

            // Bonus for proximity to center
            const centerDist = Math.abs(row - 7) + Math.abs(col - 7);
            totalScore += Math.max(0, 14 - centerDist) * 2;

            board[row][col] = EMPTY;
            return totalScore;
        }

        // Count consecutive stones and open ends for a direction
        function countLine(row, col, dr, dc, player) {
            let count = 1;
            let openEnds = 0;

            // Positive direction
            let r = row + dr;
            let c = col + dc;
            while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {
                count++;
                r += dr;
                c += dc;
            }
            if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === EMPTY) {
                openEnds++;
            }

            // Negative direction
            r = row - dr;
            c = col - dc;
            while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {
                count++;
                r -= dr;
                c -= dc;
            }
            if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === EMPTY) {
                openEnds++;
            }

            return { count, openEnds };
        }

        // ========== UI UPDATES ==========
        function updateTurnMessage() {
            const name = currentPlayer === BLACK ? 'Black' : (vsAI ? 'AI' : 'White');
            messageEl.textContent = name + "'s turn";
            messageEl.style.color = '#00d9ff';
        }

        function updatePlayerIndicator() {
            player1Box.classList.toggle('active', currentPlayer === BLACK);
            player2Box.classList.toggle('active', currentPlayer === WHITE);
        }

        function updateScores() {
            document.getElementById('score1').textContent = scores[0];
            document.getElementById('score2').textContent = scores[1];
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        // ========== START ==========
        init();
    </script>
    <script src="../js/game-utils.js"></script>
    <script src="../js/accounts.js"></script>
</body>
</html>
