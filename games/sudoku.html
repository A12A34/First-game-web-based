<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku - Game Hub</title>
    <link rel="stylesheet" href="../css/styles.css">
    <style>
        .sudoku-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .sudoku-board {
            display: grid;
            grid-template-columns: repeat(9, 45px);
            grid-template-rows: repeat(9, 45px);
            gap: 1px;
            background: #444;
            border: 3px solid #00d9ff;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 217, 255, 0.3);
        }
        
        .sudoku-cell {
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            background: #1a1a2e;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            outline: none;
        }
        
        .sudoku-cell:hover {
            background: rgba(0, 217, 255, 0.2);
        }
        
        .sudoku-cell.selected {
            background: rgba(0, 217, 255, 0.4);
        }
        
        .sudoku-cell.same-number {
            background: rgba(0, 255, 136, 0.2);
        }
        
        .sudoku-cell.given {
            color: #00d9ff;
        }
        
        .sudoku-cell.user-input {
            color: #00ff88;
        }
        
        .sudoku-cell.error {
            color: #ff6b6b;
            background: rgba(255, 107, 107, 0.2);
        }
        
        .sudoku-cell.hint {
            color: #ffaa00;
            animation: pulse 1s ease-in-out;
        }
        
        @keyframes pulse {
            0%, 100% { background: rgba(255, 170, 0, 0.3); }
            50% { background: rgba(255, 170, 0, 0.1); }
        }
        
        /* 3x3 box borders */
        .sudoku-cell:nth-child(3n) { border-right: 2px solid #00d9ff; }
        .sudoku-cell:nth-child(9n) { border-right: none; }
        .sudoku-cell:nth-child(n+19):nth-child(-n+27),
        .sudoku-cell:nth-child(n+46):nth-child(-n+54) {
            border-bottom: 2px solid #00d9ff;
        }
        
        .number-pad {
            display: grid;
            grid-template-columns: repeat(5, 50px);
            gap: 8px;
            margin-top: 15px;
        }
        
        .num-btn {
            width: 50px;
            height: 50px;
            font-size: 1.5rem;
            font-weight: bold;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .num-btn:hover {
            background: rgba(0, 217, 255, 0.3);
            border-color: #00d9ff;
        }
        
        .num-btn.completed {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .game-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .control-btn {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }
        
        .control-btn:hover {
            background: rgba(0, 217, 255, 0.3);
        }
        
        .game-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 15px 0;
        }
        
        .stat-box {
            text-align: center;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        
        .stat-label {
            font-size: 0.8rem;
            color: #a0a0a0;
        }
        
        .stat-value {
            font-size: 1.3rem;
            font-weight: bold;
            color: #00d9ff;
        }
        
        .difficulty-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 15px 0;
        }
        
        .diff-btn {
            padding: 8px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .diff-btn.active {
            background: #00d9ff;
            color: #1a1a2e;
            border-color: #00d9ff;
        }
        
        .notes-mode {
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
        }
        
        .notes-mode.active {
            background: rgba(255, 170, 0, 0.3);
            border-color: #ffaa00;
        }
        
        .cell-notes {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 100%;
            height: 100%;
            font-size: 0.6rem;
            color: #888;
        }
        
        .cell-notes span {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .hints-remaining {
            color: #ffaa00;
        }
        
        .fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 8px;
            padding: 10px 15px;
            cursor: pointer;
            font-size: 1.5rem;
            transition: background 0.3s;
        }
        .fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <button id="fullscreenBtn" class="fullscreen-btn" title="Toggle Fullscreen">‚õ∂</button>
    <div class="container">
        <a href="../index.html" class="back-btn">‚Üê Back to Games</a>
        
        <div class="game-container">
            <h1 class="game-title">üî¢ Sudoku</h1>
            
            <div class="difficulty-selector">
                <button class="diff-btn active" data-diff="easy">Easy</button>
                <button class="diff-btn" data-diff="medium">Medium</button>
                <button class="diff-btn" data-diff="hard">Hard</button>
                <button class="diff-btn" data-diff="expert">Expert</button>
            </div>
            
            <div class="game-stats">
                <div class="stat-box">
                    <div class="stat-label">Time</div>
                    <div class="stat-value" id="timer">00:00</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Errors</div>
                    <div class="stat-value" id="errors">0/3</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Hints</div>
                    <div class="stat-value hints-remaining" id="hints">3</div>
                </div>
            </div>
            
            <div class="sudoku-container">
                <div class="sudoku-board" id="board"></div>
                
                <div class="game-controls">
                    <button class="control-btn" id="undoBtn">‚Ü©Ô∏è Undo</button>
                    <button class="control-btn" id="eraseBtn">üóëÔ∏è Erase</button>
                    <button class="control-btn notes-mode" id="notesBtn">üìù Notes</button>
                    <button class="control-btn" id="hintBtn">üí° Hint</button>
                    <button class="control-btn" id="saveBtn">üíæ Save</button>
                </div>
                
                <div class="number-pad" id="numPad"></div>
            </div>
            
            <button id="newGameBtn" class="btn btn-primary" style="margin-top: 20px;">New Game</button>
            
            <div class="instructions">
                <h3>How to Play</h3>
                <p>Fill each row, column, and 3x3 box with numbers 1-9.<br>
                Each number can only appear once per row, column, and box.<br>
                Use notes to track possible numbers!</p>
            </div>
        </div>
    </div>
    
    <div id="gameOverOverlay" class="game-over-overlay hidden">
        <div class="game-over-content">
            <h2 id="endTitle">üéâ Puzzle Complete!</h2>
            <p>Time: <span id="finalTime">00:00</span><br>
            Difficulty: <span id="finalDiff">Easy</span></p>
            <button id="playAgainBtn" class="btn btn-primary">New Puzzle</button>
        </div>
    </div>

    <script>
        const board = document.getElementById('board');
        const numPad = document.getElementById('numPad');
        
        // Game state
        let puzzle = [];
        let solution = [];
        let userGrid = [];
        let notes = [];
        let selectedCell = null;
        let difficulty = 'easy';
        let errors = 0;
        let maxErrors = 3;
        let hintsRemaining = 3;
        let notesMode = false;
        let history = [];
        let timerInterval = null;
        let seconds = 0;
        let gameActive = false;
        
        const DIFFICULTY_CLUES = {
            easy: 45,
            medium: 35,
            hard: 28,
            expert: 22
        };
        
        // Sudoku generator
        function generateSolution() {
            const grid = Array(9).fill().map(() => Array(9).fill(0));
            fillGrid(grid);
            return grid;
        }
        
        function fillGrid(grid) {
            const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
            
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (grid[row][col] === 0) {
                        shuffle(numbers);
                        for (const num of numbers) {
                            if (isValid(grid, row, col, num)) {
                                grid[row][col] = num;
                                if (fillGrid(grid)) return true;
                                grid[row][col] = 0;
                            }
                        }
                        return false;
                    }
                }
            }
            return true;
        }
        
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        function isValid(grid, row, col, num) {
            // Check row
            if (grid[row].includes(num)) return false;
            
            // Check column
            if (grid.some(r => r[col] === num)) return false;
            
            // Check 3x3 box
            const boxRow = Math.floor(row / 3) * 3;
            const boxCol = Math.floor(col / 3) * 3;
            for (let r = boxRow; r < boxRow + 3; r++) {
                for (let c = boxCol; c < boxCol + 3; c++) {
                    if (grid[r][c] === num) return false;
                }
            }
            
            return true;
        }
        
        function createPuzzle(sol, clueCount) {
            const puzz = sol.map(row => [...row]);
            const cells = [];
            
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    cells.push([r, c]);
                }
            }
            
            shuffle(cells);
            
            let removed = 0;
            const toRemove = 81 - clueCount;
            
            for (const [r, c] of cells) {
                if (removed >= toRemove) break;
                puzz[r][c] = 0;
                removed++;
            }
            
            return puzz;
        }
        
        function createBoard() {
            board.innerHTML = '';
            
            for (let i = 0; i < 81; i++) {
                const cell = document.createElement('div');
                cell.className = 'sudoku-cell';
                cell.dataset.index = i;
                cell.addEventListener('click', () => selectCell(i));
                board.appendChild(cell);
            }
        }
        
        function createNumPad() {
            numPad.innerHTML = '';
            
            for (let i = 1; i <= 9; i++) {
                const btn = document.createElement('button');
                btn.className = 'num-btn';
                btn.textContent = i;
                btn.addEventListener('click', () => inputNumber(i));
                numPad.appendChild(btn);
            }
            
            const clearBtn = document.createElement('button');
            clearBtn.className = 'num-btn';
            clearBtn.textContent = '‚úï';
            clearBtn.addEventListener('click', () => eraseCell());
            numPad.appendChild(clearBtn);
        }
        
        function renderBoard() {
            const cells = board.querySelectorAll('.sudoku-cell');
            const selectedValue = selectedCell !== null ? userGrid[Math.floor(selectedCell / 9)][selectedCell % 9] : null;
            
            cells.forEach((cell, i) => {
                const row = Math.floor(i / 9);
                const col = i % 9;
                const value = userGrid[row][col];
                const isGiven = puzzle[row][col] !== 0;
                const cellNotes = notes[row][col];
                
                cell.className = 'sudoku-cell';
                
                if (i === selectedCell) {
                    cell.classList.add('selected');
                }
                
                if (isGiven) {
                    cell.classList.add('given');
                    cell.textContent = value;
                } else if (value !== 0) {
                    cell.classList.add('user-input');
                    cell.textContent = value;
                    
                    // Check if correct
                    if (value !== solution[row][col]) {
                        cell.classList.add('error');
                    }
                    
                    // Highlight same numbers
                    if (selectedValue && value === selectedValue && i !== selectedCell) {
                        cell.classList.add('same-number');
                    }
                } else if (cellNotes.length > 0) {
                    cell.innerHTML = '<div class="cell-notes">' +
                        [1,2,3,4,5,6,7,8,9].map(n => 
                            `<span>${cellNotes.includes(n) ? n : ''}</span>`
                        ).join('') + '</div>';
                } else {
                    cell.textContent = '';
                }
            });
            
            updateNumPadCount();
        }
        
        function updateNumPadCount() {
            const counts = Array(10).fill(0);
            userGrid.forEach(row => row.forEach(val => { if (val > 0) counts[val]++; }));
            
            numPad.querySelectorAll('.num-btn').forEach((btn, i) => {
                if (i < 9) {
                    btn.classList.toggle('completed', counts[i + 1] >= 9);
                }
            });
        }
        
        function selectCell(index) {
            selectedCell = index;
            renderBoard();
        }
        
        function inputNumber(num) {
            if (selectedCell === null || !gameActive) return;
            
            const row = Math.floor(selectedCell / 9);
            const col = selectedCell % 9;
            
            if (puzzle[row][col] !== 0) return; // Can't modify given cells
            
            // Save to history
            history.push({
                row, col,
                oldValue: userGrid[row][col],
                oldNotes: [...notes[row][col]]
            });
            
            if (notesMode) {
                if (notes[row][col].includes(num)) {
                    notes[row][col] = notes[row][col].filter(n => n !== num);
                } else {
                    notes[row][col].push(num);
                    notes[row][col].sort();
                }
                userGrid[row][col] = 0;
            } else {
                userGrid[row][col] = num;
                notes[row][col] = [];
                
                // Check if correct
                if (num !== solution[row][col]) {
                    errors++;
                    document.getElementById('errors').textContent = `${errors}/${maxErrors}`;
                    
                    if (errors >= maxErrors) {
                        endGame(false);
                        return;
                    }
                }
                
                // Remove this number from notes in same row/col/box
                removeNoteFromRelated(row, col, num);
                
                // Check win
                if (checkWin()) {
                    endGame(true);
                    return;
                }
            }
            
            renderBoard();
            saveProgress();
        }
        
        function removeNoteFromRelated(row, col, num) {
            // Row and column
            for (let i = 0; i < 9; i++) {
                notes[row][i] = notes[row][i].filter(n => n !== num);
                notes[i][col] = notes[i][col].filter(n => n !== num);
            }
            
            // Box
            const boxRow = Math.floor(row / 3) * 3;
            const boxCol = Math.floor(col / 3) * 3;
            for (let r = boxRow; r < boxRow + 3; r++) {
                for (let c = boxCol; c < boxCol + 3; c++) {
                    notes[r][c] = notes[r][c].filter(n => n !== num);
                }
            }
        }
        
        function eraseCell() {
            if (selectedCell === null || !gameActive) return;
            
            const row = Math.floor(selectedCell / 9);
            const col = selectedCell % 9;
            
            if (puzzle[row][col] !== 0) return;
            
            history.push({
                row, col,
                oldValue: userGrid[row][col],
                oldNotes: [...notes[row][col]]
            });
            
            userGrid[row][col] = 0;
            notes[row][col] = [];
            renderBoard();
            saveProgress();
        }
        
        function undo() {
            if (history.length === 0) return;
            
            const { row, col, oldValue, oldNotes } = history.pop();
            userGrid[row][col] = oldValue;
            notes[row][col] = oldNotes;
            renderBoard();
            saveProgress();
        }
        
        function useHint() {
            if (hintsRemaining <= 0 || !gameActive) return;
            
            // Find an empty cell
            const emptyCells = [];
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (userGrid[r][c] === 0 || userGrid[r][c] !== solution[r][c]) {
                        emptyCells.push([r, c]);
                    }
                }
            }
            
            if (emptyCells.length === 0) return;
            
            // Pick random empty cell or selected cell if empty
            let [row, col] = emptyCells[Math.floor(Math.random() * emptyCells.length)];
            
            if (selectedCell !== null) {
                const sr = Math.floor(selectedCell / 9);
                const sc = selectedCell % 9;
                if (userGrid[sr][sc] === 0 || userGrid[sr][sc] !== solution[sr][sc]) {
                    row = sr;
                    col = sc;
                }
            }
            
            userGrid[row][col] = solution[row][col];
            notes[row][col] = [];
            hintsRemaining--;
            document.getElementById('hints').textContent = hintsRemaining;
            
            const cell = board.children[row * 9 + col];
            cell.classList.add('hint');
            
            removeNoteFromRelated(row, col, solution[row][col]);
            
            if (checkWin()) {
                endGame(true);
                return;
            }
            
            renderBoard();
            saveProgress();
        }
        
        function checkWin() {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (userGrid[r][c] !== solution[r][c]) return false;
                }
            }
            return true;
        }
        
        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                seconds++;
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                document.getElementById('timer').textContent = 
                    `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }, 1000);
        }
        
        function endGame(won) {
            gameActive = false;
            clearInterval(timerInterval);
            
            if (won) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                document.getElementById('endTitle').textContent = 'üéâ Puzzle Complete!';
                document.getElementById('finalTime').textContent = 
                    `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                document.getElementById('finalDiff').textContent = 
                    difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
            } else {
                document.getElementById('endTitle').textContent = 'üòî Too Many Errors!';
                document.getElementById('finalTime').textContent = 'Better luck next time';
                document.getElementById('finalDiff').textContent = '';
            }
            
            document.getElementById('gameOverOverlay').classList.remove('hidden');
            localStorage.removeItem('sudokuProgress');
        }
        
        function newGame() {
            solution = generateSolution();
            puzzle = createPuzzle(solution, DIFFICULTY_CLUES[difficulty]);
            userGrid = puzzle.map(row => [...row]);
            notes = Array(9).fill().map(() => Array(9).fill().map(() => []));
            selectedCell = null;
            errors = 0;
            hintsRemaining = 3;
            history = [];
            seconds = 0;
            gameActive = true;
            
            document.getElementById('errors').textContent = '0/3';
            document.getElementById('hints').textContent = '3';
            document.getElementById('timer').textContent = '00:00';
            document.getElementById('gameOverOverlay').classList.add('hidden');
            
            renderBoard();
            startTimer();
            localStorage.removeItem('sudokuProgress');
        }
        
        function saveProgress() {
            const data = {
                puzzle, solution, userGrid, notes,
                errors, hintsRemaining, seconds, difficulty
            };
            localStorage.setItem('sudokuProgress', JSON.stringify(data));
        }
        
        function loadProgress() {
            const saved = localStorage.getItem('sudokuProgress');
            if (!saved) return false;
            
            try {
                const data = JSON.parse(saved);
                puzzle = data.puzzle;
                solution = data.solution;
                userGrid = data.userGrid;
                notes = data.notes;
                errors = data.errors;
                hintsRemaining = data.hintsRemaining;
                seconds = data.seconds;
                difficulty = data.difficulty;
                
                document.getElementById('errors').textContent = `${errors}/${maxErrors}`;
                document.getElementById('hints').textContent = hintsRemaining;
                
                document.querySelectorAll('.diff-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.diff === difficulty);
                });
                
                gameActive = true;
                renderBoard();
                startTimer();
                return true;
            } catch (e) {
                return false;
            }
        }
        
        // Event listeners
        document.addEventListener('keydown', e => {
            if (!gameActive) return;
            
            if (e.key >= '1' && e.key <= '9') {
                inputNumber(parseInt(e.key));
            } else if (e.key === 'Backspace' || e.key === 'Delete') {
                eraseCell();
            } else if (e.key === 'z' && e.ctrlKey) {
                undo();
            } else if (e.key === 'n') {
                notesMode = !notesMode;
                document.getElementById('notesBtn').classList.toggle('active', notesMode);
            }
            
            // Arrow key navigation
            if (selectedCell !== null) {
                let newCell = selectedCell;
                if (e.key === 'ArrowUp' && selectedCell >= 9) newCell -= 9;
                if (e.key === 'ArrowDown' && selectedCell < 72) newCell += 9;
                if (e.key === 'ArrowLeft' && selectedCell % 9 > 0) newCell -= 1;
                if (e.key === 'ArrowRight' && selectedCell % 9 < 8) newCell += 1;
                
                if (newCell !== selectedCell) {
                    e.preventDefault();
                    selectCell(newCell);
                }
            }
        });
        
        document.getElementById('undoBtn').addEventListener('click', undo);
        document.getElementById('eraseBtn').addEventListener('click', eraseCell);
        document.getElementById('hintBtn').addEventListener('click', useHint);
        document.getElementById('saveBtn').addEventListener('click', () => {
            saveProgress();
            alert('Progress saved!');
        });
        
        document.getElementById('notesBtn').addEventListener('click', () => {
            notesMode = !notesMode;
            document.getElementById('notesBtn').classList.toggle('active', notesMode);
        });
        
        document.getElementById('newGameBtn').addEventListener('click', newGame);
        document.getElementById('playAgainBtn').addEventListener('click', () => {
            document.getElementById('gameOverOverlay').classList.add('hidden');
            newGame();
        });
        
        document.querySelectorAll('.diff-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                difficulty = btn.dataset.diff;
                newGame();
            });
        });
        
        document.getElementById('fullscreenBtn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });
        
        // Initialize
        createBoard();
        createNumPad();
        
        if (!loadProgress()) {
            newGame();
        }
    </script>
    <script src="../js/accounts.js"></script>
</body>
</html>
