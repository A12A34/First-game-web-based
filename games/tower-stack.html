<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Stack - Game Hub</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../css/styles.css">
    <style>
        #gameCanvas {
            border: 3px solid #00d9ff;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 217, 255, 0.3);
            touch-action: none;
            max-width: 100%;
            height: auto;
        }

        .game-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 15px 0;
        }

        .stat-box {
            text-align: center;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            min-width: 90px;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #a0a0a0;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #00d9ff;
        }

        .stat-value.high-score {
            color: #ffc107;
        }

        .perfect-flash {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #ffc107;
            text-shadow: 0 0 30px rgba(255, 193, 7, 0.8);
            pointer-events: none;
            animation: perfectPop 0.8s ease-out forwards;
            z-index: 500;
        }

        @keyframes perfectPop {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); }
            100% { opacity: 0; transform: translate(-50%, -60%) scale(1); }
        }

        .combo-text {
            position: fixed;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
            pointer-events: none;
            animation: comboFade 0.6s ease-out forwards;
            z-index: 500;
        }

        @keyframes comboFade {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.8); }
            100% { opacity: 0; transform: translate(-50%, -60%) scale(1.1); }
        }

        .fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 8px;
            padding: 10px 15px;
            cursor: pointer;
            font-size: 1.5rem;
            transition: background 0.3s;
        }

        .fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .touch-controls {
            display: none;
            justify-content: center;
            margin-top: 15px;
        }

        .touch-btn {
            padding: 20px 60px;
            font-size: 1.2rem;
            font-weight: bold;
            background: linear-gradient(45deg, #00d9ff, #00ff88);
            color: #1a1a2e;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: transform 0.2s;
            touch-action: manipulation;
        }

        .touch-btn:active {
            transform: scale(0.95);
        }

        @media (pointer: coarse) {
            .touch-controls {
                display: flex;
            }
        }

        .game-over-content .final-score {
            font-size: 4rem;
            font-weight: bold;
            color: #ffc107;
            margin: 10px 0;
        }

        .game-over-content .new-best {
            color: #00ff88;
            font-size: 1.2rem;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <button id="fullscreenBtn" class="fullscreen-btn" title="Toggle Fullscreen">&#x26F6;</button>
    <div class="container">
        <a href="../index.html" class="back-btn">&larr; Back to Games</a>

        <div class="game-container">
            <h1 class="game-title">&#127959;&#65039; Tower Stack</h1>

            <div class="game-stats">
                <div class="stat-box">
                    <div class="stat-label">Score</div>
                    <div class="stat-value" id="score">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Best</div>
                    <div class="stat-value high-score" id="bestScore">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Combo</div>
                    <div class="stat-value" id="combo" style="color: #00ff88;">0</div>
                </div>
            </div>

            <canvas id="gameCanvas" width="400" height="600"></canvas>

            <div class="touch-controls">
                <button class="touch-btn" id="dropBtn">TAP TO DROP</button>
            </div>

            <button id="startBtn" class="btn btn-primary" style="margin-top:15px;">Start Game</button>

            <div class="instructions">
                <h3>How to Play</h3>
                <p>
                    Blocks swing back and forth across the screen.<br>
                    Tap, click, or press <strong>Space</strong> to drop the block.<br>
                    Line it up perfectly for bonus points!<br>
                    Misaligned parts get cut off, making blocks smaller.<br>
                    Game ends when you miss completely.
                </p>
            </div>
        </div>
    </div>

    <div id="gameOverOverlay" class="game-over-overlay hidden">
        <div class="game-over-content">
            <h2>Game Over!</h2>
            <div class="final-score" id="finalScore">0</div>
            <p>Blocks Stacked</p>
            <p class="new-best hidden" id="newBestMsg">New High Score!</p>
            <button id="playAgainBtn" class="btn btn-primary" style="margin-top:20px;">Play Again</button>
        </div>
    </div>

    <script>
    (function() {
        'use strict';

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        // DOM references
        const scoreEl = document.getElementById('score');
        const bestScoreEl = document.getElementById('bestScore');
        const comboEl = document.getElementById('combo');
        const startBtn = document.getElementById('startBtn');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const dropBtn = document.getElementById('dropBtn');
        const overlay = document.getElementById('gameOverOverlay');
        const finalScoreEl = document.getElementById('finalScore');
        const newBestMsg = document.getElementById('newBestMsg');

        // Game state
        let stack = [];
        let currentBlock = null;
        let debris = [];
        let particles = [];
        let score = 0;
        let combo = 0;
        let highScore = parseInt(localStorage.getItem('towerStackHighScore')) || 0;
        let gameRunning = false;
        let animationId = null;
        let cameraY = 0;
        let targetCameraY = 0;

        // Block settings
        const BLOCK_HEIGHT = 25;
        const BASE_WIDTH = 200;
        const BASE_Y = H - BLOCK_HEIGHT;
        const PERFECT_THRESHOLD = 5;
        const INITIAL_SPEED = 2.5;
        const SPEED_INCREMENT = 0.12;

        bestScoreEl.textContent = highScore;

        function getBlockColor(index) {
            const hue = (index * 18) % 360;
            return {
                top: `hsl(${hue}, 75%, 60%)`,
                front: `hsl(${hue}, 75%, 45%)`,
                light: `hsl(${hue}, 85%, 70%)`
            };
        }

        function createBaseBlock() {
            return {
                x: (W - BASE_WIDTH) / 2,
                y: BASE_Y,
                width: BASE_WIDTH,
                height: BLOCK_HEIGHT,
                color: getBlockColor(0)
            };
        }

        function createMovingBlock(index) {
            const prev = stack[stack.length - 1];
            const speed = INITIAL_SPEED + index * SPEED_INCREMENT;
            const direction = index % 2 === 0 ? 1 : -1;
            return {
                x: direction === 1 ? -prev.width : W,
                y: prev.y - BLOCK_HEIGHT,
                width: prev.width,
                height: BLOCK_HEIGHT,
                speed: speed,
                direction: direction,
                color: getBlockColor(index),
                moving: true
            };
        }

        function createDebris(x, y, width, color) {
            return {
                x: x,
                y: y,
                width: width,
                height: BLOCK_HEIGHT,
                vy: 0,
                vx: x < W / 2 ? -1.5 : 1.5,
                color: color,
                alpha: 1
            };
        }

        function spawnParticles(x, y, width, isPerfect) {
            const count = isPerfect ? 30 : 10;
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x + Math.random() * width,
                    y: y,
                    vx: (Math.random() - 0.5) * (isPerfect ? 8 : 4),
                    vy: -Math.random() * (isPerfect ? 6 : 3) - 1,
                    life: 1,
                    decay: 0.015 + Math.random() * 0.02,
                    size: isPerfect ? 3 + Math.random() * 4 : 2 + Math.random() * 2,
                    color: isPerfect ? '#ffc107' : '#00d9ff'
                });
            }
        }

        function showPerfectFlash() {
            const flash = document.createElement('div');
            flash.className = 'perfect-flash';
            flash.textContent = 'PERFECT!';
            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), 800);
        }

        function showComboText(comboCount) {
            if (comboCount < 2) return;
            const el = document.createElement('div');
            el.className = 'combo-text';
            el.textContent = `${comboCount}x COMBO!`;
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 600);
        }

        function dropBlock() {
            if (!gameRunning || !currentBlock || !currentBlock.moving) return;

            currentBlock.moving = false;
            const prev = stack[stack.length - 1];

            const overlapStart = Math.max(currentBlock.x, prev.x);
            const overlapEnd = Math.min(currentBlock.x + currentBlock.width, prev.x + prev.width);
            const overlapWidth = overlapEnd - overlapStart;

            if (overlapWidth <= 0) {
                // Missed completely
                debris.push(createDebris(currentBlock.x, currentBlock.y, currentBlock.width, currentBlock.color));
                endGame();
                return;
            }

            // Check for perfect placement
            const isPerfect = Math.abs(currentBlock.x - prev.x) < PERFECT_THRESHOLD;

            if (isPerfect) {
                // Perfect: keep block same size/position as previous
                currentBlock.x = prev.x;
                currentBlock.width = prev.width;
                combo++;
                score += 1 + combo;
                showPerfectFlash();
                showComboText(combo);
                spawnParticles(currentBlock.x, currentBlock.y, currentBlock.width, true);
            } else {
                // Cut overhang
                combo = 0;

                // Calculate left and right overhang
                const leftOverhang = prev.x - currentBlock.x;
                const rightOverhang = (currentBlock.x + currentBlock.width) - (prev.x + prev.width);

                if (leftOverhang > 0) {
                    // Overhang on the left
                    debris.push(createDebris(currentBlock.x, currentBlock.y, leftOverhang, currentBlock.color));
                    currentBlock.x = prev.x;
                    currentBlock.width = overlapWidth;
                } else if (rightOverhang > 0) {
                    // Overhang on the right
                    debris.push(createDebris(overlapEnd, currentBlock.y, rightOverhang, currentBlock.color));
                    currentBlock.width = overlapWidth;
                }

                score += 1;
                spawnParticles(currentBlock.x, currentBlock.y, currentBlock.width, false);
            }

            scoreEl.textContent = score;
            comboEl.textContent = combo;

            stack.push({
                x: currentBlock.x,
                y: currentBlock.y,
                width: currentBlock.width,
                height: currentBlock.height,
                color: currentBlock.color
            });

            // Move camera up
            if (stack.length > 10) {
                targetCameraY = (stack.length - 10) * BLOCK_HEIGHT;
            }

            // Check if block too small
            if (currentBlock.width < 8) {
                endGame();
                return;
            }

            // Next block
            currentBlock = createMovingBlock(stack.length);
        }

        function update() {
            // Move current block
            if (currentBlock && currentBlock.moving) {
                currentBlock.x += currentBlock.speed * currentBlock.direction;

                // Bounce off walls
                if (currentBlock.x + currentBlock.width > W) {
                    currentBlock.direction = -1;
                } else if (currentBlock.x < 0) {
                    currentBlock.direction = 1;
                }
            }

            // Update debris
            for (let i = debris.length - 1; i >= 0; i--) {
                const d = debris[i];
                d.vy += 0.4;
                d.y += d.vy;
                d.x += d.vx;
                d.alpha -= 0.01;
                if (d.y > H + cameraY + 100 || d.alpha <= 0) {
                    debris.splice(i, 1);
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.15;
                p.life -= p.decay;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }

            // Smooth camera
            cameraY += (targetCameraY - cameraY) * 0.08;
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, W, H);

            // Draw faint grid lines for depth
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
            ctx.lineWidth = 1;
            for (let gy = 0; gy < H + cameraY; gy += BLOCK_HEIGHT) {
                const screenY = gy - cameraY;
                if (screenY >= 0 && screenY <= H) {
                    ctx.beginPath();
                    ctx.moveTo(0, screenY + H - BASE_Y);
                    ctx.lineTo(W, screenY + H - BASE_Y);
                    ctx.stroke();
                }
            }

            ctx.save();
            ctx.translate(0, cameraY);

            // Draw stacked blocks
            for (let i = 0; i < stack.length; i++) {
                const b = stack[i];
                drawBlock(b);
            }

            // Draw current moving block
            if (currentBlock) {
                drawBlock(currentBlock);

                // Draw guide line (subtle)
                if (currentBlock.moving && stack.length > 0) {
                    const prev = stack[stack.length - 1];
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.setLineDash([5, 5]);
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(prev.x, currentBlock.y);
                    ctx.lineTo(prev.x, currentBlock.y + BLOCK_HEIGHT);
                    ctx.moveTo(prev.x + prev.width, currentBlock.y);
                    ctx.lineTo(prev.x + prev.width, currentBlock.y + BLOCK_HEIGHT);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // Draw debris
            debris.forEach(function(d) {
                ctx.globalAlpha = d.alpha;
                ctx.fillStyle = d.color.front;
                ctx.fillRect(d.x, d.y, d.width, d.height);
                ctx.globalAlpha = 1;
            });

            ctx.restore();

            // Draw particles (screen space)
            particles.forEach(function(p) {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y + cameraY, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Draw score overlay on canvas
            if (gameRunning && combo >= 2) {
                ctx.fillStyle = 'rgba(0, 255, 136, 0.3)';
                ctx.font = 'bold 16px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Combo x' + combo, W / 2, 30);
            }
        }

        function drawBlock(b) {
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(b.x + 3, b.y + 3, b.width, b.height);

            // Main block body
            var grad = ctx.createLinearGradient(b.x, b.y, b.x, b.y + b.height);
            grad.addColorStop(0, b.color.light);
            grad.addColorStop(0.5, b.color.top);
            grad.addColorStop(1, b.color.front);
            ctx.fillStyle = grad;
            ctx.fillRect(b.x, b.y, b.width, b.height);

            // Top highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.fillRect(b.x, b.y, b.width, 3);

            // Border
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(b.x, b.y, b.width, b.height);
        }

        function gameLoop() {
            update();
            draw();
            if (gameRunning) {
                animationId = requestAnimationFrame(gameLoop);
            }
        }

        function startGame() {
            // Reset
            stack = [];
            debris = [];
            particles = [];
            score = 0;
            combo = 0;
            cameraY = 0;
            targetCameraY = 0;
            currentBlock = null;

            scoreEl.textContent = '0';
            comboEl.textContent = '0';
            overlay.classList.add('hidden');
            newBestMsg.classList.add('hidden');

            // Create base block
            stack.push(createBaseBlock());

            // Create first moving block
            currentBlock = createMovingBlock(1);

            startBtn.textContent = 'Playing...';
            startBtn.disabled = true;
            gameRunning = true;
            gameLoop();
        }

        function endGame() {
            gameRunning = false;
            cancelAnimationFrame(animationId);

            let isNewBest = false;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('towerStackHighScore', highScore);
                bestScoreEl.textContent = highScore;
                isNewBest = true;
            }

            finalScoreEl.textContent = score;
            if (isNewBest) {
                newBestMsg.classList.remove('hidden');
            } else {
                newBestMsg.classList.add('hidden');
            }
            overlay.classList.remove('hidden');

            startBtn.textContent = 'Start Game';
            startBtn.disabled = false;
        }

        // Event listeners
        document.addEventListener('keydown', function(e) {
            if (e.key === ' ' || e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
                e.preventDefault();
                dropBlock();
            }
        });

        canvas.addEventListener('click', function() {
            dropBlock();
        });

        canvas.addEventListener('touchstart', function(e) {
            e.preventDefault();
            dropBlock();
        });

        dropBtn.addEventListener('click', function() {
            dropBlock();
        });

        startBtn.addEventListener('click', startGame);
        playAgainBtn.addEventListener('click', function() {
            overlay.classList.add('hidden');
            startGame();
        });

        document.getElementById('fullscreenBtn').addEventListener('click', function() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });

        // Initial draw
        stack.push(createBaseBlock());
        draw();
    })();
    </script>
    <script src="../js/game-utils.js"></script>
    <script src="../js/accounts.js"></script>
</body>
</html>
